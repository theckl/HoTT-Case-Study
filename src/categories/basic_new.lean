import sets.algebra init2 types2 sets.axioms

universes v v' v'' v''' u u' u'' u''' w 
hott_theory

namespace hott
open hott.eq hott.sigma hott.set hott.subset hott.is_trunc 
     hott.is_equiv hott.equiv

/-
We introduce precategories and categories following the HoTT book, 
Sec. 9.1. HoTT precategories have sets of homomorphisms, and HoTT categories 
prescribe univalence : Isomorphisms are equivalent to identities of objects.

As far as possible we copy the mathlib-code in [category_theory.category.default]. 
In particular, we keep the distinction of universe levels for objects and 
morphisms of a category. On the other hand, we bundle the definition of 
precategories and categories, as this makes it easier to deal with questions on
their equivalence and equality.
-/

namespace precategories

/-- A 'notation typeclass' on the way to defining a precategory. -/
@[hott]
class has_hom (obj : Type u) : Type (max u (v+1)) :=
  (hom : obj ‚Üí obj ‚Üí Set.{v})

infixr ` ‚ü∂ `:10 := has_hom.hom  -- type as \h

/- A characterisation of equality of hom-structures. -/
@[hott]
def bij_hom_map {C : Type _} (hh‚ÇÅ hh‚ÇÇ : has_hom C) :=
  Œ† x y : C, bijection (@has_hom.hom _ hh‚ÇÅ x y) 
                       (@has_hom.hom _ hh‚ÇÇ x y)

@[hott, reducible]
def bij_hom_map_id {C : Type _} (hh : has_hom C) : bij_hom_map hh hh :=
  Œª x y, identity (@has_hom.hom _ hh x y)  

@[hott, reducible]
def hom_ppred {C : Type} (hh‚ÇÄ : has_hom C) : ppred hh‚ÇÄ :=
  ppred.mk (Œª hh : has_hom C, bij_hom_map hh‚ÇÄ hh) 
           (bij_hom_map_id hh‚ÇÄ)

@[hott]
def is_contr_hom {C : Type} (hh‚ÇÄ : has_hom C) :
  is_contr (Œ£ hh : has_hom C, bij_hom_map hh‚ÇÄ hh) :=
begin 
  fapply is_contr.mk, 
  { exact ‚ü®hh‚ÇÄ, bij_hom_map_id hh‚ÇÄ‚ü© },
  { intro hb, hinduction hb with hh bij,
    hinduction hh‚ÇÄ with hom‚ÇÄ, hinduction hh with hom, 
    fapply sigma.sigma_eq, 
    { apply ap has_hom.mk, apply eq_of_homotopy2, intros x y, 
      exact (@set_eq_equiv_bij (hom‚ÇÄ x y) (hom x y))‚Åª¬π·∂† (bij x y) },
    { apply pathover_of_tr_eq, apply eq_of_homotopy2, intros x y,
      apply bijection_eq_from_map_eq, sorry } }
end              

/-- A preliminary structure on the way to defining a precategory,
containing the data, but none of the axioms. -/
@[hott]
class category_struct (obj : Type u) 
extends has_hom.{v} obj : Type (max u (v+1)) :=
(id       : Œ† a : obj, hom a a)
(comp     : Œ† {a b c : obj}, (a ‚ü∂ b) ‚Üí (b ‚ü∂ c) ‚Üí (a ‚ü∂ c))

notation `ùüô` := category_struct.id -- type as \b1
infixr ` ‚â´ `:80 := category_struct.comp -- type as \gg

/-- The structure of a precategory. -/
@[hott, class]
structure is_precat (obj : Type u) 
extends category_struct.{v} obj : Type (max u (v+1)) :=
(id_comp : ‚àÄ {a b : obj} (f : hom a b), ùüô a ‚â´ f = f)
(comp_id : ‚àÄ {a b : obj} (f : hom a b), f ‚â´ ùüô b = f)
(assoc   : ‚àÄ {a b c d : obj} (f : hom a b) (g : hom b c) (h : hom c d),
  (f ‚â´ g) ‚â´ h = f ‚â´ (g ‚â´ h))

attribute [hsimp] is_precat.id_comp is_precat.comp_id is_precat.assoc

@[hott]
structure Precategory :=
  (obj : Type u)
  (struct : is_precat obj)

@[hott] instance : has_coe_to_sort Precategory := 
  has_coe_to_sort.mk Type.{u} Precategory.obj

attribute [instance] Precategory.struct

@[hott]
def Precat_sig := Œ£ (obj : Type u), is_precat obj 

@[hott, reducible] 
def Precat_str_equiv_sig : Precategory ‚âÉ Precat_sig :=
begin
  fapply equiv.mk,
  { exact Œª C, ‚ü®C.obj, C.struct‚ü© },
  { fapply adjointify,
    { exact Œª C_sig, Precategory.mk C_sig.1 C_sig.2 },
    { intro C_sig, hsimp, rwr sigma.eta },
    { intro C, hsimp, hinduction C, hsimp } }
end

section
variables (C : Precategory) (D : Precategory) (E : Precategory)

/- Functors are defined between precategories. -/
@[hott]
structure functor :=
(obj      : C ‚Üí D)
(map      : Œ† {x y : C}, (x ‚ü∂ y) ‚Üí ((obj x) ‚ü∂ (obj y)))
(map_id   : ‚àÄ (x : C), map (ùüô x) = ùüô (obj x))
(map_comp : ‚àÄ {x y z : C} (f : x ‚ü∂ y) (g : y ‚ü∂ z), map (f ‚â´ g) = (map f) ‚â´ (map g))

infixr ` ‚•§ ` :26 := functor       

attribute [hsimp] functor.map_id
attribute [hsimp] functor.map_comp

@[hott]
def functor_eta (F : C ‚•§ D) : 
  F = functor.mk F.obj F.map F.map_id F.map_comp :=
begin hinduction F, refl end 

@[hott]
def functor_eta_mk :
  Œ† obj map map_id map_comp, functor_eta C D (functor.mk obj map map_id map_comp) = idp :=
assume obj map map_id map_comp, rfl  

@[hott]
def functor_mk_obj :
  Œ† obj map map_id map_comp, @functor.obj C D (functor.mk obj map map_id map_comp) = obj :=
assume obj map map_id map_comp, rfl   

/- Functors are equal if their maps of objects and arrows are equal. -/
@[hott]
def functor_eq {F G : C ‚•§ D} :
  Œ† (p : F.obj = G.obj), 
    (F.map =[p; Œª f : C -> D, Œ† (x y : C), (x ‚ü∂ y) -> (f x ‚ü∂ f y)] G.map) -> F = G :=
begin 
  intros p q, 
  exact (functor_eta C D F) ‚¨ù (apd01111_v2 functor.mk p q 
          (pathover_of_tr_eq (is_prop.elim _ _))  (pathover_of_tr_eq (is_prop.elim _ _)))
        ‚¨ù (functor_eta C D G)‚Åª¬π  
end  

@[hott]
def functor_eq_idp' {obj : C -> D} 
  (map : Œ† (c‚ÇÅ c‚ÇÇ : C), (c‚ÇÅ ‚ü∂ c‚ÇÇ) -> (obj c‚ÇÅ ‚ü∂ obj c‚ÇÇ)) :
  Œ† mi mc, functor_eq C D (@idp _ (functor.mk obj map mi mc).obj) idpo = idp :=
begin 
  intros mi mc,                                          
  change idp ‚¨ù (apd01111_v2 functor.mk idp idpo 
           (pathover_of_tr_eq (is_prop.elim _ _)) (pathover_of_tr_eq (is_prop.elim _ _))) 
         ‚¨ù inverse idp = _, 
  rwr idp_con, rwr idp_inv, rwr con_idp,             
  have H1 : pathover_of_tr_eq (is_prop.elim (apd011 (Œª (a : C ‚Üí D) 
              (b : Œ† {x y : C}, (x ‚ü∂ y) ‚Üí (a x ‚ü∂ a y)), Œ† (x : C), b (ùüô x) = ùüô (a x))
              idp idpo ‚ñ∏[id] mi) mi) = idpo, by apply dep_set_eq_eq,
  have H2 : pathover_of_tr_eq (is_prop.elim (apd011 (Œª (a : C ‚Üí D) (b : Œ† {x y : C}, 
              (x ‚ü∂ y) ‚Üí (a x ‚ü∂ a y)), Œ† (x y z : C) (f : x ‚ü∂ y) (g : y ‚ü∂ z), 
              b (f ‚â´ g) = b f ‚â´ b g) idp idpo ‚ñ∏[id] @mc) @mc) = idpo,
    by apply dep_set_eq_eq,        
  rwr H1, rwr H2
end

@[hott]
def functor_eq_idp {F : C ‚•§ D} :
  functor_eq C D (@idp _ F.obj) idpo = idp :=
begin hinduction F, rwr functor_eq_idp' end

@[hott]
def functor_eq_obj {F G : C ‚•§ D} :
  Œ† (p : F.obj = G.obj) q, (ap functor.obj (functor_eq C D p q)) = p :=
begin 
  intros p q, 
  change (ap _ ((functor_eta C D F) ‚¨ù (apd01111_v2 functor.mk p q 
          (pathover_of_tr_eq (is_prop.elim _ _))  (pathover_of_tr_eq (is_prop.elim _ _)))
        ‚¨ù (functor_eta C D G)‚Åª¬π)) = p, 
  rwr ap_con, rwr ap_con, hinduction F, hinduction G, 
  rwr functor_eta_mk, rwr functor_eta_mk, rwr idp_inv, rwr ap_idp, rwr ap_idp, rwr con_idp,
  rwr idp_con, rwr ap_apd01111_v2 _ _ _ _ _ _ (functor_mk_obj C D),  
  change idp ‚¨ù p ‚¨ù idp‚Åª¬π = p, rwr idp_inv, rwr con_idp, rwr idp_con  
end    

@[hott]
def functor_eq_change_path {F G : C ‚•§ D} 
  {p p' : F.obj = G.obj} (q : p = p')
  (r : (F.map =[p; Œª f : C -> D, Œ† (x y : C), (x ‚ü∂ y) -> (f x ‚ü∂ f y)] G.map)) :
  functor_eq C D p' (change_path q r) = functor_eq C D p r :=
begin hinduction q, rwr change_path_idp end  

@[hott]
def functor_eq_eta {F G : C ‚•§ D} (p : F = G) :
  functor_eq C D (ap functor.obj p) 
                 (pathover_ap (Œª f : C -> D, Œ† (x y : C), (x ‚ü∂ y) -> (f x ‚ü∂ f y)) 
                              functor.obj (apd functor.map p)) = p :=
begin 
  hinduction p, rwr apd_idp, 
  change functor_eq C D (ap functor.obj (refl F)) 
                        (change_path (ap_idp F functor.obj)‚Åª¬π idpo) = _, 
  rwr functor_eq_change_path, rwr functor_eq_idp
end  

@[hott, reducible]
def constant_functor (d : D) : 
  C ‚•§ D := 
have id_hom_eq : ‚àÄ d : D, ùüô d = ùüô d ‚â´ ùüô d, by intro d; hsimp,  
functor.mk (Œª c : C, d) (Œª c‚ÇÅ c‚ÇÇ f, ùüô d) (Œª c, rfl) 
  (Œª c‚ÇÅ c‚ÇÇ c‚ÇÉ f g, (id_hom_eq d))

@[hott]
def constant_functor_map (d : D) :
  ‚àÄ {c‚ÇÅ c‚ÇÇ : C} (h : c‚ÇÅ ‚ü∂ c‚ÇÇ), (constant_functor C D d).map h = ùüô d :=
assume c‚ÇÅ c‚ÇÇ h, rfl  

@[hott, reducible]
def id_functor : C ‚•§ C :=
  functor.mk (Œª c : C, c) (Œª c‚ÇÅ c‚ÇÇ f, f) (Œª c, idp) (Œª c‚ÇÅ c‚ÇÇ c‚ÇÉ f g, idp)  


@[hott]
structure nat_trans (F G : C ‚•§ D) :=
(app : Œ† c : C, (F.obj c) ‚ü∂ (G.obj c))
(naturality : ‚àÄ {c c' : C} (f : c ‚ü∂ c'), 
                                 (F.map f) ‚â´ (app c') = (app c) ‚â´ (G.map f))  

infixr ` ‚üπ `:10 := nat_trans _ _

end

section
variables {B : Precategory} {C : Precategory} {D : Precategory} {E : Precategory}

@[hott]
def is_faithful_functor (F : C ‚•§ D) := 
  Œ† {x y : C}, is_set_injective (@functor.map C D F x y) 

@[hott]
def is_fully_faithful_functor (F : C ‚•§ D) := 
  Œ† {x y : C}, is_set_bijective (@functor.map C D F x y)

@[hott]
def id_functor_is_fully_faithful : is_fully_faithful_functor (id_functor C) :=
  Œª x y : C, (identity (x ‚ü∂ y)).bij   

/- The composition of functors -/
@[hott, reducible]
def functor_comp (F : C ‚•§ D) (G : D ‚•§ E) : C ‚•§ E := 
begin
  fapply functor.mk,  
  { exact Œª c : C, G.obj (F.obj c) }, -- map of objects
  { intros c c' f, exact G.map (F.map f) },  -- map of morphisms
  { intro x, hsimp }, -- identity morphisms are preserved
  { intros x y x f g, hsimp } --composition of morphisms is preserved
end  

infixr ` ‚ãô `:25 := functor_comp 

@[hott]
def funct_id_comp (F : C ‚•§ D) : 
  (id_functor C ‚ãô F) = F :=
begin 
  fapply functor_eq, 
  { apply eq_of_homotopy, intro c, hsimp },
  { hsimp, change F.map =[eq_of_homotopy (Œª c : C, idp); 
                    Œª f : C -> D, Œ† (x y : C), (x ‚ü∂ y) ‚Üí (f x ‚ü∂ f y)] F.map, 
    rwr eq_of_homotopy_idp } 
end  

@[hott]
def funct_comp_id (F : C ‚•§ D) : 
  (F ‚ãô id_functor D) = F :=
begin 
  fapply functor_eq, 
  { apply eq_of_homotopy, intro c, hsimp },
  { hsimp, change F.map =[eq_of_homotopy (Œª c : C, idp); 
                    Œª f : C -> D, Œ† (x y : C), (x ‚ü∂ y) ‚Üí (f x ‚ü∂ f y)] F.map, 
    rwr eq_of_homotopy_idp } 
end 

@[hott]
def funct_comp_assoc (F : C ‚•§ D) (G : D ‚•§ E) (H : E ‚•§ B) : 
  ((F ‚ãô G) ‚ãô H) = (F ‚ãô (G ‚ãô H)) :=
begin
  fapply functor_eq, 
  { apply eq_of_homotopy, intro c, hsimp },
  { change _ =[eq_of_homotopy (Œª c : C, idp); 
                    Œª f : C -> B, Œ† (x y : C), (x ‚ü∂ y) ‚Üí (f x ‚ü∂ f y)] _, 
    rwr eq_of_homotopy_idp }
end  

end

/- Equalities of precategories can be characterized by 
   fully faithful functors that induce an equivalence on the types of 
   the objects. We use the Structure Identity Principle twice, on
   precategories and on category structures to deduce this 
   characterisation from univalence of the underlying types. -/
@[hott]
structure precat_iso (C D : Precategory) :=
  (functor : C ‚•§ D) 
  (ff : is_fully_faithful_functor functor) 
  (equiv : is_equiv functor.obj)

@[hott]
structure pc_hom_laws {C : Type _} (cat_str : category_struct C) :=
  (id_comp : ‚àÄ {a b : C} (f : a ‚ü∂ b), ùüô a ‚â´ f = f)
  (comp_id : ‚àÄ {a b : C} (f : a ‚ü∂ b), f ‚â´ ùüô b = f)
  (assoc   : ‚àÄ {a b c d : C} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),
               (f ‚â´ g) ‚â´ h = f ‚â´ (g ‚â´ h))

@[hott, instance]
def pc_hom_laws_is_prop {C : Type _} (cat_str : category_struct C) :
  is_prop (pc_hom_laws cat_str) :=
begin 
  fapply is_prop.mk, intros hl‚ÇÅ hl‚ÇÇ, 
  hinduction hl‚ÇÅ with ic‚ÇÅ ci‚ÇÅ as‚ÇÅ, hinduction hl‚ÇÇ with ic‚ÇÇ ci‚ÇÇ as‚ÇÇ, 
  fapply ap0111', 
  all_goals { exact is_prop.elim _ _ } 
end

@[hott, reducible]
def pc_str_sig (C : Type _) := 
  Œ£ (cat_str : category_struct C), pc_hom_laws cat_str 

@[hott, reducible]
def precat_str_eqv_sig (C : Type _) : 
    (is_precat C) ‚âÉ (pc_str_sig C) :=
begin
  fapply equiv.mk,
  { intro pc_str,  
    exact dpair pc_str.to_category_struct (@pc_hom_laws.mk _ 
                pc_str.to_category_struct pc_str.id_comp 
                pc_str.comp_id pc_str.assoc) },
  { fapply adjointify, 
    { intro pc_str_sig, hinduction pc_str_sig with cat_str pc_hom_laws,
      exact @is_precat.mk _ cat_str pc_hom_laws.id_comp 
                        pc_hom_laws.comp_id pc_hom_laws.assoc },
    { intro pc_str_sig, hinduction pc_str_sig with cat_str pc_hom_laws,
      hsimp, hinduction pc_hom_laws, hsimp },
    { intro pc_str, hinduction pc_str with cat_str ic ci as, 
      hsimp } }
end

@[hott, reducible]
def pc_str_sig_eq_eqv_cat_str_eq {C : Type _} :
  Œ† (pc_str_sig‚ÇÅ pc_str_sig‚ÇÇ : pc_str_sig C), 
    (pc_str_sig‚ÇÅ = pc_str_sig‚ÇÇ) ‚âÉ ((pc_str_sig‚ÇÅ.1) = pc_str_sig‚ÇÇ.1) :=
Œª pc_str_sig‚ÇÅ pc_str_sig‚ÇÇ, subtype_eq_equiv _ _

/- This reduces the equality of precategory structures to the
   equality of the underlying category structures. -/
@[hott]
def precat_str_eqv_cat_str (C : Type _) 
                           (pc_str‚ÇÅ pc_str‚ÇÇ : is_precat C) : 
    (pc_str‚ÇÅ = pc_str‚ÇÇ) ‚âÉ pc_str‚ÇÅ.to_category_struct =
                           pc_str‚ÇÇ.to_category_struct :=
eq_equiv_fn_eq_of_equiv (precat_str_eqv_sig C) pc_str‚ÇÅ pc_str‚ÇÇ ‚¨ùe
pc_str_sig_eq_eqv_cat_str_eq (precat_str_eqv_sig C pc_str‚ÇÅ) 
                             (precat_str_eqv_sig C pc_str‚ÇÇ)

@[hott]
structure precat_iso_of_obj {C‚ÇÄ C : Precategory} 
  (obj_eqv : C‚ÇÄ ‚âÉ C.obj) :=
  (hom_map      : Œ† {x y : C‚ÇÄ}, (x ‚ü∂ y) ‚Üí 
                             ((obj_eqv x) ‚ü∂ (obj_eqv y)))
  (hom_map_id   : ‚àÄ {x : C‚ÇÄ}, hom_map (ùüô x) = ùüô (obj_eqv x))
  (hom_map_comp : ‚àÄ {x y z : C‚ÇÄ} (f : x ‚ü∂ y) (g : y ‚ü∂ z), 
                   hom_map (f ‚â´ g) = (hom_map f) ‚â´ (hom_map g)) 
  (ff : Œ† {x y : C‚ÇÄ}, is_set_bijective (@hom_map x y) )

@[hott] 
structure pc_hom_ops {C : Type _} (hh : has_hom C) :=
  (id       : Œ† a : C, a ‚ü∂ a)
  (comp     : Œ† {a b c : C}, (a ‚ü∂ b) ‚Üí (b ‚ü∂ c) ‚Üí (a ‚ü∂ c))

@[hott]
def cat_str_sig (C : Type _) := Œ£ (hh : has_hom C), pc_hom_ops hh

@[hott]
def cat_str_eqv_sig (C : Type _) : (category_struct C) ‚âÉ (cat_str_sig C) :=
begin
  fapply equiv.mk,
  { intro cat_str, 
    exact dpair cat_str.to_has_hom (@pc_hom_ops.mk _ 
                   cat_str.to_has_hom cat_str.id cat_str.comp) },
  { fapply adjointify,
    { intro cat_str_sig, 
      exact @category_struct.mk _ cat_str_sig.1 cat_str_sig.2.id 
                                              cat_str_sig.2.comp },
    { intro cat_str_sig, hinduction cat_str_sig with hh hom_ops, 
      hinduction hom_ops with id comp, hsimp },
    { intro cat_str, hinduction cat_str with hh id comp, hsimp } }
end

@[hott, reducible]
def cat_str_dep_ppred {C : Type} (cat_str‚ÇÄ : cat_str_sig C) :           
  dep_ppred cat_str‚ÇÄ.1 cat_str‚ÇÄ.2 :=
dep_ppred.mk (hom_ppred cat_str‚ÇÄ.1) (Œª hh hh_ops bhm, sorry) sorry

@[hott]
def precat_streq_eqv_iso_obj {C‚ÇÄ : Precategory} (str : is_precat C‚ÇÄ) :
  (C‚ÇÄ.struct = str) ‚âÉ @precat_iso_of_obj C‚ÇÄ 
                  (Precategory.mk C‚ÇÄ.obj str) (@equiv.rfl C‚ÇÄ) :=
sorry     

@[hott]
def precat_iso_of_obj_equiv_iso (C‚ÇÄ C : Precategory) :
  (Œ£ (obj_eqv : C‚ÇÄ ‚âÉ C.obj), @precat_iso_of_obj C‚ÇÄ 
     (Precategory.mk C.obj C.struct) obj_eqv) ‚âÉ precat_iso C‚ÇÄ C :=
begin
  fapply equiv.mk,
  { intro pc_oi_sig, fapply precat_iso.mk,
    { exact functor.mk pc_oi_sig.1 pc_oi_sig.2.hom_map
                       pc_oi_sig.2.hom_map_id 
                       pc_oi_sig.2.hom_map_comp },
    { exact pc_oi_sig.2.ff },
    { exact pc_oi_sig.1.to_is_equiv } },
  { fapply adjointify,
    { intro pc_iso, fapply sigma.mk, 
      { exact equiv.mk pc_iso.functor.obj pc_iso.equiv },
      { exact precat_iso_of_obj.mk pc_iso.functor.map
          pc_iso.functor.map_id pc_iso.functor.map_comp pc_iso.ff } },
    { intro pc_iso, hinduction pc_iso with functor ff equiv,
      hinduction functor with obj map map_id map_comp, hsimp },
    { intro pc_oi_sig, hinduction pc_oi_sig with pc_oi pc_io, 
      hinduction pc_oi with map equiv, 
      hinduction pc_io, hsimp } }  
end

@[hott, reducible]
def precat_obj_ppred (C‚ÇÄ : Precategory) : ppred C‚ÇÄ.obj :=
  ppred.mk (Œª C : Type _, C‚ÇÄ ‚âÉ C) (@equiv.rfl C‚ÇÄ)

@[hott, reducible]
def precat_dep_ppred (C‚ÇÄ : Precategory) : dep_ppred C‚ÇÄ.obj C‚ÇÄ.struct :=              
  dep_ppred.mk (precat_obj_ppred C‚ÇÄ) 
    (Œª C pc_str_C pc_obj, @precat_iso_of_obj C‚ÇÄ 
                             (Precategory.mk C pc_str_C) pc_obj) 
    (precat_iso_of_obj.mk (id_functor C‚ÇÄ).map (id_functor C‚ÇÄ).map_id
       (id_functor C‚ÇÄ).map_comp (@id_functor_is_fully_faithful C‚ÇÄ)) 

@[hott]
def precat_sig_equiv_obj_iso (C‚ÇÄ C : Precategory) : 
  ((Precat_str_equiv_sig C‚ÇÄ) = (Precat_str_equiv_sig C)) ‚âÉ
  (Œ£ (pc_obj : C‚ÇÄ ‚âÉ C.obj), @precat_iso_of_obj C‚ÇÄ 
                     (Precategory.mk C.obj C.struct) pc_obj) :=
begin
  fapply struct_id_char_of_contr C‚ÇÄ.struct (precat_dep_ppred C‚ÇÄ)
                                 _ _ (Precat_str_equiv_sig C),
  { fapply is_contr.mk, 
    { exact ‚ü®C‚ÇÄ.obj, @equiv.rfl C‚ÇÄ‚ü© },
    { intro C_obj_iso, hinduction C_obj_iso with C_obj pc_oi_C,
      change _ ‚âÉ C_obj at pc_oi_C,
      change dpair C‚ÇÄ.obj (@equiv.rfl C‚ÇÄ) = _,   
      fapply sigma.sigma_eq, 
      { exact ua pc_oi_C },
      { fapply obj_char_id_eq (eq_equiv_equiv C‚ÇÄ.obj) } } },
  { fapply is_contr.mk, 
    { exact ‚ü®C‚ÇÄ.struct, (precat_dep_ppred _).dep_base‚ü© },
    { --have p : (precat_dep_ppred C‚ÇÄ).ppred_fst.base = @equiv.rfl C‚ÇÄ, from rfl,
      intro pc_str_iso, hinduction pc_str_iso with pc_str pc_iso,
      --change precat_iso_of_obj _ at pc_iso, rwr p at pc_iso,
      fapply sigma.sigma_eq, 
      { exact (precat_streq_eqv_iso_obj pc_str)‚Åª¬π·∂† pc_iso },
      { fapply obj_char_id_eq (@precat_streq_eqv_iso_obj C‚ÇÄ) 
                              pc_str pc_iso } } }
end   

@[hott]
def precat_id_equiv_iso (C D : Precategory) : 
  (C = D) ‚âÉ (precat_iso C D) :=
(eq_equiv_fn_eq_of_equiv Precat_str_equiv_sig C D) ‚¨ùe
(precat_sig_equiv_obj_iso C D) ‚¨ùe
(precat_iso_of_obj_equiv_iso C D)

end precategories


open precategories
namespace categories

/- Definition of categorical isomorphisms. -/
@[hott]
structure iso {C : Type u} [is_precat.{v} C] (a b : C) :=
  (hom : a ‚ü∂ b)
  (inv : b ‚ü∂ a) 
  (r_inv : inv ‚â´ hom = ùüô b) 
  (l_inv : hom ‚â´ inv = ùüô a) 

postfix `‚Åª¬π ∞`:std.prec.max_plus := iso.inv

infix ` ‚âÖ `:25 := iso

@[hott]
structure is_iso {C : Precategory} {a b : C} (f : a ‚ü∂ b) :=
  (inv : b ‚ü∂ a)
  (r_inv : inv ‚â´ f = ùüô b)
  (l_inv : f ‚â´ inv = ùüô a)

@[hott]
def is_iso_to_iso {C : Precategory} {a b : C} (f : a ‚ü∂ b) 
  (H : is_iso f) : a ‚âÖ b := iso.mk f H.inv H.r_inv H.l_inv

@[hott]
def iso_to_is_iso {C : Precategory} {a b : C} (f : a ‚âÖ b) : 
  is_iso f.hom := is_iso.mk f.inv f.r_inv f.l_inv  

@[hott]
def iso.eta {C : Precategory} {a b : C} (i : a ‚âÖ b) : 
  i = iso.mk i.hom i.inv i.r_inv i.l_inv :=
begin hinduction i, hsimp end  

@[hott, hsimp]
def inv_iso {C : Precategory} {a b : C} (i : a ‚âÖ b) : b ‚âÖ a :=
  iso.mk i.inv i.hom i.l_inv i.r_inv

/- Calculation rules for isomorphisms. -/
@[hott, hsimp]
def iso_inv_inv {C : Precategory} {a b : C} (i : a ‚âÖ b) :
  (inv_iso i)‚Åª¬π ∞ = i.hom :=
by hsimp 

@[hott, hsimp]
def iso_rcancel {C : Precategory} {a b c : C} (i : a ‚âÖ b)
  {g h : c ‚ü∂ a} : g ‚â´ i.hom = h ‚â´ i.hom -> g = h :=
assume pc, 
have pc_inv : (g ‚â´ i.hom) ‚â´ i.inv = (h ‚â´ i.hom) ‚â´ i.inv, from 
  ap (Œª h : c ‚ü∂ b, h ‚â´ i.inv) pc,
calc   g = g ‚â´ ùüô a : by hsimp
     ... = g ‚â´ (i.hom ‚â´ i.inv) : by rwr <-i.l_inv
     ... = (g ‚â´ i.hom) ‚â´ i.inv : by hsimp
     ... = (h ‚â´ i.hom) ‚â´ i.inv : by rwr pc_inv
     ... = h ‚â´ (i.hom ‚â´ i.inv) : by hsimp
     ... = h ‚â´ ùüô a : by rwr i.l_inv     
     ... = h : by hsimp 

@[hott, hsimp]
def iso_lcancel {C : Precategory} {a b c : C} (i : a ‚âÖ b)
  {g h : b ‚ü∂ c} : i.hom ‚â´ g = i.hom ‚â´ h -> g = h :=
assume cp, 
have cp_inv : i.inv ‚â´ (i.hom ‚â´ g) = i.inv ‚â´ (i.hom ‚â´ h), from 
  ap (Œª h : a ‚ü∂ c, i.inv ‚â´ h) cp,
calc   g = ùüô b ‚â´ g : by hsimp
     ... = (i.inv ‚â´ i.hom) ‚â´ g : by rwr <-i.r_inv
     ... = i.inv ‚â´ (i.hom ‚â´ g) : by hsimp
     ... = i.inv ‚â´ (i.hom ‚â´ h) : by rwr cp_inv
     ... = (i.inv ‚â´ i.hom) ‚â´ h : by hsimp
     ... = ùüô b ‚â´ h : by rwr i.r_inv     
     ... = h : by hsimp 

@[hott, hsimp]
def iso_move_lr {C : Precategory} {a b c : C} (i : a ‚âÖ b)
  (g : b ‚ü∂ c) (h : a ‚ü∂ c) : i.hom ‚â´ g = h -> g = i.inv ‚â´ h :=
assume pcr,
have i.inv ‚â´ i.hom ‚â´ g = i.inv ‚â´ h, from ap (Œª h : a ‚ü∂ c, i.inv ‚â´ h) pcr,
calc g   = ùüô b ‚â´ g : by hsimp
     ... = (i.inv ‚â´ i.hom) ‚â´ g : by rwr <-i.r_inv
     ... = i.inv ‚â´ (i.hom ‚â´ g) : by hsimp
     ... = i.inv ‚â´ h : by rwr pcr   

@[hott, hsimp]
def iso_move_rl {C : Precategory} {a b c : C} (i : a ‚âÖ b)
  (g : c ‚ü∂ a) (h : c ‚ü∂ b) : g ‚â´ i.hom = h -> g = h ‚â´ i.inv :=
assume pcl,
have (g ‚â´ i.hom) ‚â´ i.inv = h ‚â´ i.inv, from ap (Œª h : c ‚ü∂ b, h ‚â´ i.inv) pcl,
calc g   = g ‚â´ ùüô a : by hsimp
     ... = g ‚â´ (i.hom ‚â´ i.inv) : by rwr <-i.l_inv
     ... = (g ‚â´ i.hom) ‚â´ i.inv : by hsimp
     ... = h ‚â´ i.inv : by rwr pcl     

/- Isomorphisms are uniquely determined by their underlying homomorphism:
   The inverse map by functorial equalities, and the functorial equalities 
   because the types of homomorphisms are sets. -/
@[hott]
def hom_eq_to_iso_eq {C : Precategory} {a b : C} {i j : a ‚âÖ b} :
  i.hom = j.hom -> i = j :=
assume hom_eq, 
have inv_eq : i.inv = j.inv, from 
  calc i.inv = i.inv ‚â´ ùüô a : by hsimp
       ...   = i.inv ‚â´ (j.hom ‚â´ j.inv) : by rwr j.l_inv‚Åª¬π 
       ...   = (i.inv ‚â´ j.hom) ‚â´ j.inv : by hsimp
       ...   = (i.inv ‚â´ i.hom) ‚â´ j.inv : by rwr hom_eq‚Åª¬π
       ...   = ùüô b ‚â´ j.inv : by rwr i.r_inv
       ...   = j.inv : by hsimp,
let R := Œª (f : a ‚ü∂ b) (g : b ‚ü∂ a), g ‚â´ f = ùüô b,
    L := Œª (f : a ‚ü∂ b) (g : b ‚ü∂ a), f ‚â´ g = ùüô a in
have r_inv_eq : i.r_inv =[ap011 R hom_eq inv_eq; id] j.r_inv, from 
  begin apply pathover_of_tr_eq, apply is_set.elim end,
have l_inv_eq : i.l_inv =[ap011 L hom_eq inv_eq; id] j.l_inv, from 
  begin apply pathover_of_tr_eq, apply is_set.elim end, 
calc   i = iso.mk i.hom i.inv i.r_inv i.l_inv : iso.eta i 
     ... = iso.mk j.hom j.inv j.r_inv j.l_inv : 
                                        ap0111 iso.mk hom_eq inv_eq r_inv_eq l_inv_eq
     ... = j : (iso.eta j)‚Åª¬π

@[hott, hsimp]
def id_is_iso {C : Type u} [is_precat.{v} C] (a : C) : a ‚âÖ a := 
  have inv_eq : ùüô a ‚â´ ùüô a = ùüô a, by hsimp,
  iso.mk (ùüô a) (ùüô a) inv_eq inv_eq

@[hott, hsimp]
def idtoiso {C : Type u} [is_precat.{v} C] {a b : C} : (a = b) -> (a ‚âÖ b) :=
  begin intro eq, exact eq ‚ñ∏[Œª c, a ‚âÖ c] id_is_iso a end

/- `idtoiso` is natural. -/
@[hott, hsimp]
def idtoiso_refl_eq {C : Precategory} (a : C) : idtoiso (refl a) = id_is_iso a :=
  by hsimp

@[hott]
def id_inv_iso_inv {C : Precategory} {c‚ÇÅ c‚ÇÇ : C} (p : c‚ÇÅ = c‚ÇÇ) :
  idtoiso p‚Åª¬π = inv_iso (idtoiso p) := 
begin hinduction p, refl end 

/- The next two facts correspond to [HoTT-Book, Lem.9.1.9]. -/
@[hott]
def id_hom_tr_comp {C : Precategory} {c‚ÇÅ c‚ÇÇ d : C} (p : c‚ÇÅ = c‚ÇÇ)
  (h : c‚ÇÅ ‚ü∂ d) : p ‚ñ∏ h = (idtoiso p)‚Åª¬π ∞ ‚â´ h :=
begin hinduction p, hsimp end   

@[hott]
def id_hom_tr_comp' {C : Precategory} {c‚ÇÅ c‚ÇÇ d : C} (p : c‚ÇÅ = c‚ÇÇ)
  (h : d ‚ü∂ c‚ÇÅ) : p ‚ñ∏ h = h ‚â´ (idtoiso p).hom :=
begin hinduction p, hsimp end

/-- The structure of a category. -/
@[hott]
class is_cat (obj : Type u) extends is_precat.{v} obj :=
  (ideqviso : ‚àÄ a b : obj, is_equiv (@idtoiso _ _ a b)) 

attribute [instance] is_cat.ideqviso

@[hott]
structure Category :=
  (obj : Type u)
  (struct : is_cat obj)
/-
@[hott, instance]
def Cat.to_obj : has_coe_to_sort Category := 
  has_coe_to_sort.mk Type.{u} Category.obj
-/
@[hott, instance]
def Cat.to_Precat : has_coe Category Precategory := 
  has_coe.mk (Œª C : Category, Precategory.mk C.obj (C.struct.to_is_precat))

attribute [instance] Category.struct

@[hott, hsimp]
def category.isotoid {C : Category} : 
  Œ† {a b : C}, a ‚âÖ b -> a = b :=
assume a b iso,  
@is_equiv.inv _ _ (@idtoiso C.obj _ a b) (is_cat.ideqviso a b) iso  

@[hott, hsimp]
def category.idtoiso_rinv {C : Category} {a b : C} :
  ‚àÄ i : a ‚âÖ b, idtoiso (idtoiso‚Åª¬π·∂† i) = i :=
is_equiv.right_inv (@idtoiso _ _ a b) 

@[hott, hsimp]
def category.idtoiso_linv {C : Category} {a b : C} :
  ‚àÄ p : a = b, idtoiso‚Åª¬π·∂† (idtoiso p) = p :=
is_equiv.left_inv (@idtoiso _ _ a b) 

@[hott, hsimp]
def category.idtoiso_rinv' {C : Category} {a b : C} :
  ‚àÄ i : a ‚âÖ b, idtoiso (category.isotoid i) = i :=
is_equiv.right_inv (@idtoiso _ _ a b) 

@[hott, hsimp]
def category.idtoiso_linv' {C : Category} {a b : C} :
  ‚àÄ p : a = b, category.isotoid (idtoiso p) = p :=
is_equiv.left_inv (@idtoiso _ _ a b) 

@[hott]
def isotoid_id_refl {C : Category} :
  Œ† (a : C), category.isotoid (id_is_iso a) = refl a :=
begin 
  intro a, rwr <- idtoiso_refl_eq  a, 
  exact category.idtoiso_linv (refl a) 
end 

@[hott]
def iso_hom_tr_comp {C : Category} {c‚ÇÅ c‚ÇÇ d : C} (i : c‚ÇÅ ‚âÖ c‚ÇÇ)
  (h : c‚ÇÅ ‚ü∂ d) : (idtoiso‚Åª¬π·∂† i) ‚ñ∏ h = i‚Åª¬π ∞ ‚â´ h :=
begin 
  rwr <-(category.idtoiso_rinv i),  
  rwr category.idtoiso_linv (idtoiso‚Åª¬π·∂† i),
  exact id_hom_tr_comp (idtoiso‚Åª¬π·∂† i) h
end 

@[hott]
def iso_hom_tr_comp' {C : Category} {c‚ÇÅ c‚ÇÇ d : C} (i : c‚ÇÅ ‚âÖ c‚ÇÇ)
  (h : d ‚ü∂ c‚ÇÅ) : (idtoiso‚Åª¬π·∂† i) ‚ñ∏ h = h ‚â´ i.hom :=
begin 
  rwr <-(category.idtoiso_rinv i),  
  rwr category.idtoiso_linv (idtoiso‚Åª¬π·∂† i),
  exact id_hom_tr_comp' (idtoiso‚Åª¬π·∂† i) h
end

end categories

end hott