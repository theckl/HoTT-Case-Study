import sets.algebra categories.subobj categories.subcat categories.examples 
       categories.strict_cat categories.diagrams 

universes v v' u u' w
hott_theory

namespace hott
open hott.eq hott.is_trunc hott.trunc hott.is_equiv hott.set hott.subset 
     hott.precategories hott.categories hott.categories.strict

/- We introduce limits of diagrams mapped to categories, by using cones to 
   pick the universal object and encode the universal property.

   As far as possible we copy the mathlib-code in [category_theory.limits]. -/

namespace categories.limits

@[hott]
structure cone {J : Type _} [is_strict_cat J] {C : Type _} 
  [is_precat C] (F : J ‚•§ C) :=
(X : C)
(œÄ : (@constant_functor J _ C _ X) ‚üπ F)

@[hott, reducible, hsimp]
def cone.leg {J : Type _} [is_strict_cat J] {C : Type _} 
  [is_precat C] {F : J ‚•§ C} (cF : cone F) : 
  Œ† j : J, cF.X ‚ü∂ F.obj j := 
begin intro j, exact cF.œÄ.app j end

@[hott]
def cone.fac {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] {F : J ‚•§ C} (s : cone F) : 
  ‚àÄ {j k : J} (f : j ‚ü∂ k), s.œÄ.app j ‚â´ F.map f = s.œÄ.app k :=
begin intros j k f, rwr <- s.œÄ.naturality f, hsimp end   

@[hott]
def cone_eq {J : Type _} [is_strict_cat J] {C : Type _} 
  [is_precat C] {F : J ‚•§ C} (cF‚ÇÅ cF‚ÇÇ : cone F) :
  Œ† (p : cF‚ÇÅ.X = cF‚ÇÇ.X), (Œ† j : J, cone.leg cF‚ÇÅ j =[p; Œª c, c ‚ü∂ F.obj j] 
                                   cone.leg cF‚ÇÇ j) -> cF‚ÇÅ = cF‚ÇÇ :=
begin 
  hinduction cF‚ÇÅ with X‚ÇÅ œÄ‚ÇÅ, hinduction cF‚ÇÇ with X‚ÇÇ œÄ‚ÇÇ,
  intro vertex_eq, change X‚ÇÅ = X‚ÇÇ at vertex_eq, hinduction vertex_eq, 
  intro legs_eq,  
  fapply apd011 cone.mk, exact idp, apply pathover_idp_of_eq,
  hinduction œÄ‚ÇÅ with app‚ÇÅ nat‚ÇÅ, hinduction œÄ‚ÇÇ with app‚ÇÇ nat‚ÇÇ,
  fapply apd011 nat_trans.mk, 
  { apply eq_of_homotopy, intro j, exact eq_of_pathover_idp (legs_eq j) },
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ } 
end

@[hott]
structure cone_map {J : Type _} [is_strict_cat J] {C : Type _} 
  [is_precat C] {F : J ‚•§ C} (cF‚ÇÅ cF‚ÇÇ : cone F) :=
(v_lift : cF‚ÇÅ.X ‚ü∂ cF‚ÇÇ.X)
(fac : Œ† (j : J), v_lift ‚â´ cF‚ÇÇ.œÄ.app j = cF‚ÇÅ.œÄ.app j)

@[hott]
def cone_map_eq {J : Type _} [is_strict_cat J] {C : Type _} 
  [is_precat C] {F : J ‚•§ C} {cF‚ÇÅ cF‚ÇÇ : cone F} (m‚ÇÅ m‚ÇÇ : cone_map cF‚ÇÅ cF‚ÇÇ) :
  m‚ÇÅ.v_lift = m‚ÇÇ.v_lift -> m‚ÇÅ = m‚ÇÇ :=
begin
  hinduction m‚ÇÅ with vl‚ÇÅ fac‚ÇÅ, hinduction m‚ÇÇ with vl‚ÇÇ fac‚ÇÇ, intro v_lift_eq,
  fapply apd011, exact v_lift_eq, 
  apply pathover_of_tr_eq, apply eq_of_homotopy, intro j, exact is_prop.elim _ _
end

@[hott]
structure is_limit {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] {F : J ‚•§ C} (t : cone F) :=
(lift : Œ† (s : cone F), cone_map s t)
(uniq : ‚àÄ (s : cone F) (m : cone_map s t), m.v_lift = (lift s).v_lift)

@[hott, instance]
def is_limit_is_prop {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] {F : J ‚•§ C} (t : cone F) : is_prop (is_limit t) :=
begin
  apply is_prop.mk, intros l‚ÇÅ l‚ÇÇ, 
  hinduction l‚ÇÅ with lift‚ÇÅ uniq‚ÇÅ, hinduction l‚ÇÇ with lift‚ÇÇ uniq‚ÇÇ,
  fapply apd011,
  { apply eq_of_homotopy, intro s, apply cone_map_eq, exact uniq‚ÇÇ s (lift‚ÇÅ s) },
  { apply pathover_of_tr_eq, apply eq_of_homotopy2, intros s m, exact is_prop.elim _ _ }
end

@[hott] 
def lift_itself_id {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] {F : J ‚•§ C} {t : cone F} (l : is_limit t) : 
  (l.lift t).v_lift = ùüô t.X :=
have t_fac : ‚àÄ j : J, ùüô t.X ‚â´ t.œÄ.app j = t.œÄ.app j, by intro j; hsimp,  
(l.uniq _ (cone_map.mk (ùüô t.X) t_fac))‚Åª¬π             

@[hott]
def limit_cone_point_iso {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] {F : J ‚•§ C} {s t : cone F} (l‚Çõ : is_limit s) 
  (l‚Çú : is_limit t) : Œ£ i : s.X ‚âÖ t.X, i.hom = (l‚Çú.lift s).v_lift :=
let st := (l‚Çú.lift s).v_lift, ts := (l‚Çõ.lift t).v_lift in 
have s_fac : ‚àÄ j : J, (st ‚â´ ts) ‚â´ s.œÄ.app j = s.œÄ.app j, from assume j,
  calc (st ‚â´ ts) ‚â´ s.œÄ.app j = st ‚â´ (ts ‚â´ s.œÄ.app j) : is_precat.assoc _ _ _
       ... = st ‚â´ t.œÄ.app j : by rwr (l‚Çõ.lift t).fac j
       ... = s.œÄ.app j : by rwr (l‚Çú.lift s).fac j,
have t_fac : ‚àÄ j : J, (ts ‚â´ st) ‚â´ t.œÄ.app j = t.œÄ.app j, from assume j, 
  calc (ts ‚â´ st) ‚â´ t.œÄ.app j = ts ‚â´ (st ‚â´ t.œÄ.app j) : is_precat.assoc _ _ _
       ... = ts ‚â´ s.œÄ.app j : by rwr (l‚Çú.lift s).fac j 
       ... = t.œÄ.app j : by rwr (l‚Çõ.lift t).fac j,
have comp_s : st ‚â´ ts = ùüô s.X, from (l‚Çõ.uniq _ (cone_map.mk _ s_fac)) ‚¨ù lift_itself_id l‚Çõ, 
have comp_t : ts ‚â´ st = ùüô t.X, from (l‚Çú.uniq _ (cone_map.mk _ t_fac)) ‚¨ù lift_itself_id l‚Çú,
‚ü®iso.mk st (is_iso.mk ts comp_t comp_s), rfl‚ü©

/- `limit_cone F` contains a cone over `F` together with the information that 
   it is a limit. -/
@[hott]
structure limit_cone {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] (F : J ‚•§ C) :=
(cone : cone F)
(is_limit : is_limit cone)

@[hott]
def limit_cone_eq {J : Type _} [is_strict_cat J] 
  {C : Type u} [is_precat.{v} C] (F : J ‚•§ C) (lc‚ÇÅ lc‚ÇÇ : limit_cone F) :
  lc‚ÇÅ.cone = lc‚ÇÇ.cone -> lc‚ÇÅ = lc‚ÇÇ :=
begin
  hinduction lc‚ÇÅ with cone‚ÇÅ is_limit‚ÇÅ, hinduction lc‚ÇÇ with cone‚ÇÇ is_limit‚ÇÇ,
  intro cone_eq, fapply apd011, exact cone_eq,
  apply pathover_of_tr_eq, exact is_prop.elim _ _
end

/- `has_limit F` represents the mere existence of a limit for `F`. This allows
   to define it as a class with instances. -/ 
@[hott]   
class has_limit {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] (F : J ‚•§ C) :=
mk' :: (exists_limit : ‚à•limit_cone F‚à•)

@[hott]
def has_limit.mk {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] {F : J ‚•§ C} (d : limit_cone F) :=
has_limit.mk' (tr d)  

@[hott]
def has_limit_eq {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] {F : J ‚•§ C} (hlF‚ÇÅ hlF‚ÇÇ : has_limit F) : hlF‚ÇÅ = hlF‚ÇÇ :=
begin
  hinduction hlF‚ÇÅ with el‚ÇÅ, hinduction hlF‚ÇÇ with el‚ÇÇ,
  apply ap has_limit.mk', exact is_prop.elim _ _
end

@[hott, instance]
def has_limit_is_prop {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_precat.{v} C] {F : J ‚•§ C} : is_prop (has_limit F) :=
is_prop.mk has_limit_eq

/- If `C` is a category, the limit cone vertices of two instances of 
  `limit_cone F` are equal since they are determined up to isomorphism. Then 
   the "legs" of the cones and the lifts of the universal property are 
   determined up to composition with the automorphism associated to this 
   equality of limit cone points, and limit cones are equal. 
   
   Thus, we can produce a `limit_cone F` from `has_limit F`. -/
@[hott]
def limit_cone_is_unique {J : Type _} [is_strict_cat J] 
  {C : Type u} [is_cat.{v} C] (F : J ‚•§ C) : 
  ‚àÄ lc‚ÇÅ lc‚ÇÇ : limit_cone F, lc‚ÇÅ = lc‚ÇÇ :=
begin
  intros lc‚ÇÅ lc‚ÇÇ, 
  hinduction lc‚ÇÅ with cone‚ÇÅ is_limit‚ÇÅ, hinduction lc‚ÇÇ with cone‚ÇÇ is_limit‚ÇÇ,
  let lcp_iso := limit_cone_point_iso is_limit‚ÇÅ is_limit‚ÇÇ,
  apply limit_cone_eq, fapply cone_eq,
  { exact idtoiso‚Åª¬π·∂† lcp_iso.1 },
  { intro j, apply pathover_of_tr_eq,
    change idtoiso‚Åª¬π·∂† lcp_iso.1 ‚ñ∏[Œª c : C, c ‚ü∂ F.obj j] (cone.leg cone‚ÇÅ j) = _, 
    apply eq.concat (iso_hom_tr_comp lcp_iso.1 (cone.leg cone‚ÇÅ j)),
    apply inverse, apply iso_move_lr, 
    have p : lcp_iso.fst.hom = (is_limit‚ÇÇ.lift cone‚ÇÅ).v_lift, from lcp_iso.2,
    rwr p, exact (is_limit‚ÇÇ.lift _).fac _ }
end    

@[hott, instance]
def limit_cone_is_prop {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_cat.{v} C] (F : J ‚•§ C) : is_trunc -1 (limit_cone F) :=
is_prop.mk (limit_cone_is_unique F)

@[hott]
def get_limit_cone {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_cat.{v} C] (F : J ‚•§ C) [has_limit F] : limit_cone F :=
untrunc_of_is_trunc (has_limit.exists_limit F)  

@[hott]
def limit.cone {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_cat.{v} C] (F : J ‚•§ C) [has_limit F] : cone F := 
(get_limit_cone F).cone

@[hott]
def limitcone_is_limit  {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_cat.{v} C] (F : J ‚•§ C) [has_limit F] : is_limit (limit.cone F) :=
(get_limit_cone F).is_limit

@[hott]
def limit {J : Type _} [is_strict_cat J] {C : Type u} [is_cat.{v} C]
  (F : J ‚•§ C) [has_limit F] : C := (limit.cone F).X

@[hott]
def limit_leg {J : Type _} [is_strict_cat J] {C : Type u} 
  [is_cat.{v} C] (F : J ‚•§ C) [has_limit F] (j : J) : 
  limit F ‚ü∂ F.obj j := (limit.cone F).œÄ.app j 

@[hott]
def diag_eq_lim_eq_lim {J : Type _} [is_strict_cat J] {C : Type u} [is_cat.{v} C]
  {F F' : J ‚•§ C} (p : F = F') [hlF : has_limit F] [hlF' : has_limit F'] : 
  @limit _ _ _ _ F hlF = @limit _ _ _ _ F' hlF' :=
apd011 (@limit _ _ _ _) p (pathover_of_tr_eq (has_limit_eq _ _))  

@[hott]
def diag_inv_eq_lim_eq {J : Type _} [is_strict_cat J] {C : Type u} [is_cat.{v} C]
  {F F' : J ‚•§ C} (p : F = F') [hlF : has_limit F] [hlF' : has_limit F'] :
  (diag_eq_lim_eq_lim p‚Åª¬π) = (diag_eq_lim_eq_lim p)‚Åª¬π :=
begin
  change apd011 _ _ _ = eq.inverse (apd011 _ _ _), 
  rwr apd011_inv, apply ap (apd011 limit p‚Åª¬π), rwr pathover_of_tr_eq_inv, 
  apply ap pathover_of_tr_eq, exact is_prop.elim _ _ 
end

@[hott]
def diag_eq_leg_eq {J : Type _} [is_strict_cat J] {C : Type _} [is_cat C]
  {F F' : J ‚•§ C} (p : F = F') (j : J) [hlF : has_limit F] [hlF' : has_limit F'] :
  limit_leg F' j = ((ap (Œª F : J ‚•§ C, F.obj j) p) ‚ñ∏[Œª d : C, limit F' ‚ü∂ d] 
                   ((diag_eq_lim_eq_lim p) ‚ñ∏[Œª c : C, c ‚ü∂ F.obj j] limit_leg F j)) :=
@tr_tr_fn2_fn2_fn _ C C _ _ p _ _ _ (pathover_of_tr_eq (has_limit_eq (p ‚ñ∏ hlF) hlF'))
                 (Œª d e : C, d ‚ü∂ e) _ _ (Œª (F : J ‚•§ C) (hlF : has_limit F), 
                                                          @limit_leg _ _ _ _ F hlF j)

/- Limits of diagrams of shapes with a functor between them are not necessarily naturally
   mapped to each other. But limits of diagrams of isomorphic shapes are naturally 
   isomorphic and hence equal. -/
@[hott]
def cone_to_diag_iso_cone {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C] (H : J‚ÇÅ ‚âÖ J‚ÇÇ) 
  {F : J‚ÇÇ.obj ‚•§ C} (s : cone F) : cone (H.hom ‚ãô F) :=
begin
  fapply cone.mk, exact s.X, fapply nat_trans.mk, 
  { intro j‚ÇÅ, exact s.œÄ.app (H.hom.obj j‚ÇÅ) },
  { intros j‚ÇÅ j‚ÇÅ' f, exact s.œÄ.naturality _ }
end 

@[hott]
def cone_to_diag_iso_cone_inv {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C] (H : J‚ÇÅ ‚âÖ J‚ÇÇ) 
  {F : J‚ÇÇ.obj ‚•§ C} (t : cone (H.hom ‚ãô F)) : cone F :=
begin
  fapply cone.mk, exact t.X, fapply nat_trans.mk, 
  { intro j‚ÇÇ, exact t.œÄ.app (H.ih.inv.obj j‚ÇÇ) ‚â´ F.map ((functor_eq_to_nat_trans H.ih.r_inv).app j‚ÇÇ) },
  { intros j‚ÇÇ j‚ÇÇ' f, change (constant_functor t.X).map (H.ih.inv.map f) ‚â´ _ = _,
    rwr <- is_precat.assoc ((constant_functor t.X).map f), rwr t.œÄ.naturality (H.ih.inv.map f), 
    rwr is_precat.assoc, change _ ‚â´ F.map _ ‚â´ _ = _, rwr <- F.map_comp, rwr is_precat.assoc, rwr <- F.map_comp,
    change _ = _ ‚â´ F.map (_ ‚â´ ((ùüô J‚ÇÇ : J‚ÇÇ.obj ‚•§ J‚ÇÇ.obj).map f)), 
    rwr <- (functor_eq_to_nat_trans H.ih.r_inv).naturality f }
end 

@[hott]
def cone_to_diag_iso_cone_map {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C] (H : J‚ÇÅ ‚âÖ J‚ÇÇ) 
  {F : J‚ÇÇ.obj ‚•§ C} (cF : cone F) (cHF : cone (H.hom ‚ãô F)) : 
  cone_map ((cone_to_diag_iso_cone_inv H cHF)) cF -> cone_map cHF (cone_to_diag_iso_cone H cF) :=
begin 
  intro m, fapply cone_map.mk,
  { exact m.v_lift },
  { intro j‚ÇÅ, change _ ‚â´ cF.œÄ.app (H.hom.obj j‚ÇÅ) = _, rwr m.fac (H.hom.obj j‚ÇÅ), 
    change cHF.œÄ.app _ ‚â´ F.map _ = _, 
    have p : F.map ((functor_eq_to_nat_trans H.ih.r_inv).app (H.hom.obj j‚ÇÅ)) = 
             (H.hom ‚ãô F).map ((functor_eq_to_nat_trans H.ih.l_inv).app j‚ÇÅ), from 
    begin 
      change F.map _ = F.map _, apply ap (@precategories.functor.map _ _ _ _ F _ _), 
      change (idtoiso _).hom = H.hom.map (idtoiso _).hom, rwr funct_idtoiso, 
      apply ap (Œª p, (idtoiso p).hom), exact is_prop.elim _ _ 
    end,
    rwr p, rwr <- cHF.œÄ.naturality, change ùüô _ ‚â´ _ = _, rwr is_precat.id_comp }
end

@[hott]
def cone_to_diag_iso_cone_map_inv {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C] (H : J‚ÇÅ ‚âÖ J‚ÇÇ) 
  {F : J‚ÇÇ.obj ‚•§ C} (cF : cone F) (cHF : cone (H.hom ‚ãô F)) : 
  cone_map cHF (cone_to_diag_iso_cone H cF) -> cone_map ((cone_to_diag_iso_cone_inv H cHF)) cF :=
begin 
  intro m, fapply cone_map.mk,
  { exact m.v_lift },
  { intro j‚ÇÇ, change _ = cHF.œÄ.app _ ‚â´ _, rwr <- m.fac (H.ih.inv.obj j‚ÇÇ), rwr is_precat.assoc, 
    change _ = _ ‚â´ cF.œÄ.app _ ‚â´ _, rwr <- cF.œÄ.naturality, change _ = _ ‚â´ ùüô _ ‚â´ _, 
    rwr is_precat.id_comp }
end

@[hott]
def cone_to_diag_iso_cone_map_vert {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C] (H : J‚ÇÅ ‚âÖ J‚ÇÇ) 
  {F : J‚ÇÇ.obj ‚•§ C} {cF : cone F} {cHF : cone (H.hom ‚ãô F)} 
  (m : cone_map ((cone_to_diag_iso_cone_inv H cHF)) cF) : 
  m.v_lift = (cone_to_diag_iso_cone_map H cF cHF m).v_lift := idp

@[hott]
def cone_to_diag_iso_cone_map_vert_inv {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C] (H : J‚ÇÅ ‚âÖ J‚ÇÇ) 
  {F : J‚ÇÇ.obj ‚•§ C} {cF : cone F} {cHF : cone (H.hom ‚ãô F)} (m : cone_map cHF ((cone_to_diag_iso_cone H cF))) : 
  m.v_lift = (cone_to_diag_iso_cone_map_inv H cF cHF m).v_lift := idp

@[hott]
def diag_id_iso_cone {J : Strict_Categories} {C : Type u} [is_cat.{v} C] {F : J.obj ‚•§ C} (cF : cone F) : 
  cone_to_diag_iso_cone (id_iso J) cF = cone.mk cF.X (nat_trans.mk cF.œÄ.app cF.œÄ.naturality) := idp

@[hott]
def diag_iso_cone_vertex {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C]
  (H : J‚ÇÅ ‚âÖ J‚ÇÇ) {F : J‚ÇÇ.obj ‚•§ C} (cF : cone F) : 
  (cone_to_diag_iso_cone H cF).X = cF.X :=
idp 

@[hott]
def diag_iso_cone_legs {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C]
  (H : J‚ÇÅ ‚âÖ J‚ÇÇ) {F : J‚ÇÇ.obj ‚•§ C} (cF : cone F) : Œ† (j‚ÇÅ : J‚ÇÅ.obj),
  (cone.leg (cone_to_diag_iso_cone H cF) j‚ÇÅ) = 
  ((diag_iso_cone_vertex H cF)‚Åª¬π ‚ñ∏[Œª c : C, c ‚ü∂ F.obj (H.hom.obj j‚ÇÅ)] cone.leg cF (H.hom.obj j‚ÇÅ)) :=
begin intro j‚ÇÅ, exact idp end

@[hott]
def diag_iso_cone_legs_fac {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C]
  (H : J‚ÇÅ ‚âÖ J‚ÇÇ) {F : J‚ÇÇ.obj ‚•§ C} (cF : cone F) : Œ† (j‚ÇÅ : J‚ÇÅ.obj), 
  ((idtoiso (diag_iso_cone_vertex H cF)).hom ‚â´ cone.leg cF (H.hom.obj j‚ÇÅ)) = 
                                      cone.leg (cone_to_diag_iso_cone H cF) j‚ÇÅ :=
begin intro j‚ÇÅ, rwr diag_iso_cone_legs, rwr id_hom_tr_comp end

@[hott]
def diag_iso_cone_is_lim {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C]
  (H : J‚ÇÅ ‚âÖ J‚ÇÇ) {F : J‚ÇÇ.obj ‚•§ C} {cF : cone F} (lcF : is_limit cF) : 
  is_limit (cone_to_diag_iso_cone H cF) :=
begin
  fapply is_limit.mk, 
  { intro s, apply cone_to_diag_iso_cone_map, apply lcF.lift },
  { intros s m, rwr <- cone_to_diag_iso_cone_map_vert, rwr cone_to_diag_iso_cone_map_vert_inv,
    apply lcF.uniq }
end

@[hott, instance]
def diag_iso_has_lim_to_has_lim {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C]
  (H : J‚ÇÅ ‚âÖ J‚ÇÇ) {F : J‚ÇÇ.obj ‚•§ C} [hlF : has_limit F] : has_limit (H.hom ‚ãô F) :=
begin 
  apply has_limit.mk, fapply limit_cone.mk, 
  exact cone_to_diag_iso_cone H (limit.cone F),
  exact diag_iso_cone_is_lim H (limitcone_is_limit _)
end

@[hott]
def diag_iso_lim_eq_lim {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C]
  (H : J‚ÇÅ ‚âÖ J‚ÇÇ) (F : J‚ÇÇ.obj ‚•§ C) [hlF : has_limit F] : 
  @limit _ _ _ _ (H.hom ‚ãô F) (diag_iso_has_lim_to_has_lim H) = limit F  :=
begin exact (diag_iso_cone_vertex H (limit.cone F)) end

@[hott]
def diag_iso_lim_legs_eq {J‚ÇÅ J‚ÇÇ : Strict_Categories} {C : Type u} [is_cat.{v} C]
  (H : J‚ÇÅ ‚âÖ J‚ÇÇ) (F : J‚ÇÇ.obj ‚•§ C) [hlF : has_limit F] :
  Œ† (j‚ÇÅ : J‚ÇÅ.obj), (idtoiso (diag_iso_lim_eq_lim H F)).hom ‚â´ limit_leg F (H.hom.obj j‚ÇÅ) =
                limit_leg (H.hom ‚ãô F) j‚ÇÅ :=
assume j‚ÇÅ, diag_iso_cone_legs_fac H (limit.cone F) j‚ÇÅ


/- More general classes of existence of limits -/
@[hott]
class has_limits_of_shape (J : Type _) [is_strict_cat J] 
  (C : Type u) [is_cat.{v} C] :=
(has_limit : Œ† F : J ‚•§ C, has_limit F)

@[hott, instance]
def has_lims_shape_is_prop (J : Type _) [is_strict_cat J] (C : Type u) [is_cat.{v} C] : 
  is_prop (has_limits_of_shape J C) :=
begin 
  apply is_prop.mk, intros hls‚ÇÅ hls‚ÇÇ, hinduction hls‚ÇÅ, hinduction hls‚ÇÇ,
  apply ap has_limits_of_shape.mk, exact is_prop.elim _ _ 
end

@[hott, priority 100]
instance has_limit_of_has_limits_of_shape
  {J : Type _} [is_strict_cat J] (C : Type u) [is_cat.{v} C] 
  [has_limits_of_shape J C] (F : J ‚•§ C) : has_limit F :=
has_limits_of_shape.has_limit F

@[hott]
class has_limits (C : Type u) [is_cat.{v} C] :=
  (has_limit_of_shape : Œ† {J : Type _} [is_strict_cat J], 
                                       has_limits_of_shape J C )  

@[hott]
class has_product {C : Type u} [is_cat.{v} C] {J : Set.{u'}} 
  (f : J -> C) := (has_limit : has_limit (discrete.functor f)) 

@[hott, priority 100]
instance has_limit_of_has_product {C : Type u} [is_cat.{v} C] 
  {J : Set.{u'}} (f : J -> C) [has_product f] : has_limit (discrete.functor f) := 
has_product.has_limit f  

@[hott]
abbreviation pi_obj {C : Type u} [is_cat.{v} C] {J : Set.{u'}} (f : J ‚Üí C) 
  [has_product f] := limit (discrete.functor f)

notation `‚àè ` f:20 := pi_obj f

@[hott]
class has_products (C : Type u) [is_cat.{v} C] := 
  (has_limit_of_shape : Œ† J : Set.{u'}, has_limits_of_shape (discrete J) C)

@[hott, instance, priority 100]
def has_limits_of_shape_of_has_products 
  (J : Set.{u'}) (C : Type u) [is_cat.{v} C] [has_products.{v u u'} C] :
  has_limits_of_shape (discrete J) C :=
has_products.has_limit_of_shape C J

@[hott]
instance has_product_of_has_products {C : Type u} [is_cat.{v} C] 
  [has_products C] {J : Set.{u'}} (f : J -> C) : has_product f :=
‚ü®@has_limits_of_shape.has_limit _ _ _ _ 
       (has_products.has_limit_of_shape C J) (discrete.functor f)‚ü©

@[hott, instance]
def has_product_of_has_limits_of_shape {C : Type u} [is_cat.{v} C] 
  {J : Set.{u'}} [has_limits_of_shape (discrete J) C] (f : J -> C) : 
  has_product f :=
‚ü®has_limits_of_shape.has_limit (discrete.functor f)‚ü© 

@[hott, instance]
def has_products_of_has_limits (C : Type u) [is_cat.{v} C] [c : has_limits C] : 
  has_products C :=
has_products.mk (Œª J, @has_limits.has_limit_of_shape C _ c (discrete J) _)

/-- A fan over `f : J ‚Üí C` consists of a collection of maps from an object `P`
    to every `f j`. This is enough to determine a cone which factorizes through    
    the product. -/
@[hott]    
abbreviation fan {J : Set.{u'}} {C : Type u} [is_cat.{v} C] (f : J ‚Üí C) := 
  cone (discrete.functor f)

@[hott, hsimp]
def fan.mk {J : Set.{u'}} (C : Type u) [is_cat.{v} C] {f : J ‚Üí C} {P : C} 
  (p : Œ† j, P ‚ü∂ f j) : fan f :=
cone.mk P (discrete.nat_trans p)

@[hott, hsimp] 
def pi.lift {J : Set.{u'}} {C : Type u} [is_cat.{v} C] {f : J ‚Üí C} [has_product f]
  {P : C} (p : Œ† j, P ‚ü∂ f j) : P ‚ü∂ ‚àè f :=
((get_limit_cone (discrete.functor f)).is_limit.lift (fan.mk _ p)).v_lift  

@[hott, hsimp] 
def pi.œÄ {J : Set.{u'}} {C : Type u} [is_cat.{v} C] (f : J ‚Üí C) [has_product f] 
  (j : J) : ‚àè f ‚ü∂ f j :=
(limit.cone (discrete.functor f)).œÄ.app j 

@[hott]
def pi.hom_is_lift {J : Set.{u'}} {C : Type u} [is_cat.{v} C] {f : J ‚Üí C} 
  [has_product f] {P : C} (h : P ‚ü∂ ‚àè f) : 
  h = pi.lift (Œª j : J, h ‚â´ (pi.œÄ _ j)) :=
let p := Œª j : J, h ‚â´ (pi.œÄ f j),
    c := fan.mk _ p,
    lc := get_limit_cone (discrete.functor f) in     
begin 
  change h = (lc.is_limit.lift c).v_lift, 
  apply is_limit.uniq lc.is_limit c (cone_map.mk h (Œª j, rfl))
end  

@[hott]
def pi.lift_œÄ_eq {J : Set.{u'}} (C : Type u) [is_cat.{v} C] {f : J ‚Üí C} 
  [has_product f] {P : C} (p : Œ† j : J, P ‚ü∂ f j) : 
  ‚àÄ j : J, pi.lift p ‚â´ pi.œÄ _ j = p j :=
((get_limit_cone (discrete.functor f)).is_limit.lift (fan.mk _ p)).fac  

@[hott]
def pi.lift_uniq {J : Set.{u'}} (C : Type u) [is_cat.{v} C] {f : J ‚Üí C} 
  [has_product f] {P : C} {p : Œ† j : J, P ‚ü∂ f j} :=
((get_limit_cone (discrete.functor f)).is_limit.lift (fan.mk _ p)).fac   

@[hott]
def pi.lift_fac {J : Set.{u'}} {C : Type u} [is_cat.{v} C] {f : J ‚Üí C} 
  [has_product f] {P Q : C} (g : Q ‚ü∂ P) (h : Œ† j : J, P ‚ü∂ f j) :
  pi.lift (Œª j, g ‚â´ h j) = g ‚â´ pi.lift h :=
let ch := fan.mk _ h, p := Œª j : J, g ‚â´ h j, cp := fan.mk _ p, 
    lc := get_limit_cone (discrete.functor f) in  
begin
  have p_fac : Œ† j : J, (g ‚â´ pi.lift h) ‚â´ pi.œÄ _ j = g ‚â´ h j, from 
    begin intro j, rwr is_precat.assoc, rwr pi.lift_œÄ_eq end,  
  exact (is_limit.uniq lc.is_limit cp (cone_map.mk (g ‚â´ pi.lift h) p_fac))‚Åª¬π
end  

@[hott]
def pi_hom {J : Set.{u'}} {C : Type u} [is_cat.{v} C] {f g : J -> C} 
  [has_product f] [has_product g] (h : Œ† j : J, f j ‚ü∂ g j) : ‚àè f ‚ü∂ ‚àè g :=
pi.lift (Œª j : J, pi.œÄ f j ‚â´ h j)

notation `‚àèh ` h:20 := pi_hom h

@[hott]
def pi_hom_id {J : Set.{u'}} {C : Type u} [is_cat.{v} C] (f : J -> C) [has_product f] : 
  pi_hom (Œª j, ùüô (f j)) = ùüô (‚àè f) :=
have H : (Œª j, pi.œÄ f j ‚â´ ùüô (f j)) = Œª j, ùüô (‚àè f) ‚â´ pi.œÄ f j, from 
  begin apply eq_of_homotopy, intro j, hsimp end,  
begin change pi.lift (Œª j, pi.œÄ f j ‚â´ ùüô (f j)) = _, rwr H, rwr <- pi.hom_is_lift end  

@[hott]
def pi_hom_comp {J : Set.{u'}} {C : Type u} [is_cat.{v} C] {f g h : J -> C} 
  [has_product f] [has_product g] [has_product h] (i‚ÇÅ : Œ† j : J, f j ‚ü∂ g j)  
  (i‚ÇÇ : Œ† j : J, g j ‚ü∂ h j) : (‚àèh i‚ÇÅ) ‚â´ (‚àèh i‚ÇÇ) = ‚àèh (Œª j, i‚ÇÅ j ‚â´ i‚ÇÇ j) :=
have H : (Œª j, pi.lift (Œª j, pi.œÄ f j ‚â´ i‚ÇÅ j) ‚â´ pi.œÄ g j ‚â´ i‚ÇÇ j) = 
                                             Œª j, pi.œÄ f j ‚â´ i‚ÇÅ j ‚â´ i‚ÇÇ j, from   
  begin 
    apply eq_of_homotopy, intro j, 
    change pi.lift (Œª j, pi.œÄ f j ‚â´ i‚ÇÅ j) ‚â´ pi.œÄ g j ‚â´ i‚ÇÇ j = _,
    rwr <- is_precat.assoc, rwr pi.lift_œÄ_eq, 
    change (pi.œÄ f j ‚â´ i‚ÇÅ j) ‚â´ i‚ÇÇ j = pi.œÄ f j ‚â´ i‚ÇÅ j ‚â´ i‚ÇÇ j, rwr is_precat.assoc 
  end,
calc pi.lift (Œª j, pi.œÄ f j ‚â´ i‚ÇÅ j) ‚â´ pi.lift (Œª j, pi.œÄ g j ‚â´ i‚ÇÇ j) = 
           pi.lift (Œª j, pi.lift (Œª j, pi.œÄ f j ‚â´ i‚ÇÅ j) ‚â´ pi.œÄ g j ‚â´ i‚ÇÇ j) : 
                                                          by rwr <- pi.lift_fac
     ... = pi.lift (Œª j, pi.œÄ f j ‚â´ i‚ÇÅ j ‚â´ i‚ÇÇ j) : by rwr H

@[hott]
def pi_proj_sset {J : Set.{u'}} {A B : Subset J} (inc : A ‚äÜ B) {C : Type u} 
  [is_cat.{v} C] (f : pred_Set B -> C) [has_product f] 
  [has_product (f ‚àò pred_Set_inc inc)] : ‚àè f ‚ü∂ ‚àè (f ‚àò pred_Set_inc inc) :=
pi.lift (Œª j : pred_Set A, pi.œÄ f (pred_Set_inc inc j))


/- `parallel_pair f g` is the diagram in `C` consisting of the two morphisms `f` and `g` 
   with common domain and codomain. -/
@[hott, hsimp]
def parallel_pair_obj {C : Type _} [is_cat C] {a b : C} 
  (f g : a ‚ü∂ b) : walking_parallel_pair -> C :=
Œª s, match s with
     | wp_pair.up := a
     | wp_pair.down := b
     end    

@[hott, hsimp]
def parallel_pair_map {C : Type _} [is_cat C] {a b : C} 
  (f g : a ‚ü∂ b) : Œ† {s t : walking_parallel_pair}, 
  (s ‚ü∂ t) -> (parallel_pair_obj f g s ‚ü∂ parallel_pair_obj f g t) :=
assume s t h, 
begin
  hinduction s, 
  { hinduction t,
    { exact ùüô a },
    { hinduction h,
      { exact f },
      { exact g } } },
  { hinduction t,
    { hinduction h },
    { exact ùüô b } }
end 

@[hott, hsimp]
def parallel_pair_map_id {C : Type _} [is_cat C] {a b : C} 
  (f g : a ‚ü∂ b) : ‚àÄ s : walking_parallel_pair, 
  parallel_pair_map f g (ùüô s) = ùüô (parallel_pair_obj f g s) :=
by intro s; hinduction s; hsimp; hsimp   

@[hott, hsimp]
def parallel_pair_map_comp {C : Type _} [is_cat C] 
  {a b : C} (f g : a ‚ü∂ b) : ‚àÄ {s t u : walking_parallel_pair} 
  (h : s ‚ü∂ t) (i : t ‚ü∂ u), parallel_pair_map f g (h ‚â´ i) = 
                  (parallel_pair_map f g h) ‚â´ (parallel_pair_map f g i) :=
assume s t u h i,
begin
  hinduction s,
  { hinduction t,
    { hsimp },
    { hinduction u,
      { hinduction i },
      { rwr wpp_ci, hsimp } } },
  { hinduction t,
    { induction h },
    { hsimp } }
end  

@[hott]
def parallel_pair {C : Type _} [is_cat C] {a b : C} 
  (f g : a ‚ü∂ b) : walking_parallel_pair ‚•§ C :=
precategories.functor.mk (parallel_pair_obj f g) 
                           (@parallel_pair_map _ _ _ _ f g) 
                           (parallel_pair_map_id f g) 
                           (@parallel_pair_map_comp _ _ _ _ f g)   

/- A cone over a parallel pair is called a `fork`. -/
@[hott]
abbreviation fork {C : Type _} [is_cat C] {a b : C} (f g : a ‚ü∂ b) := 
  @cone walking_parallel_pair _ _ _ (parallel_pair f g) 

set_option trace.class_instances false

@[hott] 
def fork_map {C : Type u} [is_cat.{v} C] {a b : C} {f g : a ‚ü∂ b} (fk : fork f g) :
  ‚Ü•(fk.X ‚ü∂ a) := fk.œÄ.app wp_up

@[hott]
def fork_eq {C : Type u} [is_cat.{v} C] {a b : C} {f g : a ‚ü∂ b} (fk : fork f g) :
  (fork_map fk) ‚â´ f = (fork_map fk) ‚â´ g :=
cone.fac fk wp_left ‚¨ù (cone.fac fk wp_right)‚Åª¬π   
   
@[hott]
def fork.of_i {C : Type u} [is_cat.{v} C] {a b c : C} 
  {f g : a ‚ü∂ b} (i : c ‚ü∂ a) (w : i ‚â´ f = i ‚â´ g) : fork f g :=
have œÄ : @constant_functor ‚Ü•walking_parallel_pair _ C _ c ‚üπ parallel_pair f g, from
  let app :=  @wp_pair.rec (Œª x, c ‚ü∂ (parallel_pair f g).obj x) i (i ‚â´ f) in
  have naturality : ‚àÄ (x x' : walking_parallel_pair) (h : x ‚ü∂ x'), 
          ((@constant_functor ‚Ü•walking_parallel_pair _ C _ c).map h) ‚â´ (app x') = 
           (app x) ‚â´ ((parallel_pair f g).map h), from 
  begin
    intros x x' h, 
    hinduction x,
    { hinduction x',
      { hinduction h, hsimp },
      { hinduction h, 
        { hsimp, refl },
        { hsimp, exact w } } },  
    { hinduction x', 
      { hinduction h },
      { hinduction h, hsimp } }
  end,           
  nat_trans.mk app naturality,   
cone.mk c œÄ 

/- Limits of parallel pairs are `equalizers`. -/
@[hott]
class has_equalizer {C : Type u} [is_cat.{v} C] {a b : C} (f g : a ‚ü∂ b) := 
  (has_limit : has_limit (parallel_pair f g))

@[hott, priority 100]
instance has_limit_of_has_equalizer {C : Type u} [is_cat.{v} C] {a b : C} (f g : a ‚ü∂ b)
  [has_equalizer f g] : has_limit (parallel_pair f g) := 
has_equalizer.has_limit f g 

@[hott]
def equalizer {C : Type u} [is_cat.{v} C] {a b : C} (f g : a ‚ü∂ b) [has_equalizer f g] :=
  limit (parallel_pair f g) 

@[hott, reducible] 
def equalizer_map {C : Type u} [is_cat.{v} C] {a b : C} (f g : a ‚ü∂ b) [has_equalizer f g] :
  equalizer f g ‚ü∂ a := fork_map (limit.cone (parallel_pair f g))    

@[hott] 
def equalizer_eq {C : Type u} [is_cat.{v} C] {a b : C} (f g : a ‚ü∂ b) [has_equalizer f g] :
  equalizer_map f g ‚â´ f = equalizer_map f g ‚â´ g := fork_eq (limit.cone (parallel_pair f g)) 

@[hott]
def fork_lift {C : Type u} [is_cat.{v} C] {a b : C} {f g : a ‚ü∂ b} [has_equalizer f g] 
  (fk : fork f g) : fk.X ‚ü∂ equalizer f g := 
((get_limit_cone (parallel_pair f g)).is_limit.lift fk).v_lift  

@[hott]
def fork_lift_uniq {C : Type u} [is_cat.{v} C] {a b : C} {f g : a ‚ü∂ b} [has_equalizer f g] 
  (fk : fork f g) (m : fk.X ‚ü∂ equalizer f g) : 
  m ‚â´ (equalizer_map f g) = fk.œÄ.app wp_up -> m = fork_lift fk :=
begin 
  let equ := limit.cone (parallel_pair f g), 
  intro H,
  have m_fac : Œ† j : walking_parallel_pair, m ‚â´ equ.œÄ.app j = fk.œÄ.app j, from 
  begin
    intro j, hinduction j, 
    { exact H }, 
    { change m ‚â´ (limit.cone (parallel_pair f g)).œÄ.app wp_down = fk.œÄ.app wp_down,
      rwr <- cone.fac (limit.cone (parallel_pair f g)) wp_left, 
      rwr <- cone.fac fk wp_left, rwr <- is_precat.assoc m _ _, 
      change (m ‚â´ equalizer_map f g) ‚â´ _ = _, rwr H }
  end,
  exact (get_limit_cone (parallel_pair f g)).is_limit.uniq fk (cone_map.mk m m_fac),
end  
    
@[hott]
class has_equalizers (C : Type u) [is_cat.{v} C] := 
  (has_limit_of_shape : has_limits_of_shape walking_parallel_pair C)

@[hott, instance]
def has_equalizer_of_has_equalizers {C : Type u} [is_cat.{v} C] 
  [has_equalizers C] {a b : C} (f g : a ‚ü∂ b) : has_equalizer f g :=
‚ü®@has_limits_of_shape.has_limit _ _ _ _ 
       (has_equalizers.has_limit_of_shape C) (parallel_pair f g)‚ü©

@[hott, instance]
def has_equalizer_of_has_limits_of_shape {C : Type u} [is_cat.{v} C] 
  [H : has_limits_of_shape walking_parallel_pair C] {a b : C} (f g : a ‚ü∂ b) : 
  has_equalizer f g :=
‚ü®@has_limits_of_shape.has_limit _ _ _ _ H (parallel_pair f g)‚ü© 

@[hott, instance]
def has_equalizers_of_has_limits (C : Type u) [is_cat.{v} C] [H : has_limits C] : 
  has_equalizers C :=
has_equalizers.mk (@has_limits.has_limit_of_shape C _ H walking_parallel_pair _)

/- An equalizer is a subobject of the domain of the parallel pair. -/
@[hott]
def equalizer_as_subobject (C : Type u) [is_cat.{v} C] {a b : C} (f g : a ‚ü∂ b) 
  [H : has_equalizer f g] : @subobject C _ a :=
begin
  let e := equalizer_map f g, let He : e ‚â´ f = e ‚â´ g := equalizer_eq f g,
  fapply subobject.mk,
  { exact @equalizer _ _ _ _ f g H},
  { exact e },
  { intros d h h' Hm, 
    have Hhe : (h ‚â´ e) ‚â´ f = (h ‚â´ e) ‚â´ g, from 
      (is_precat.assoc h e f) ‚¨ù ap (category_struct.comp h) He ‚¨ù (is_precat.assoc h e g)‚Åª¬π,
    have Hhf : h = fork_lift (fork.of_i (h ‚â´ e) Hhe), from 
      fork_lift_uniq (fork.of_i (h ‚â´ e) Hhe) h rfl,  
    have Hh'e : (h' ‚â´ e) ‚â´ f = (h' ‚â´ e) ‚â´ g, from
      (is_precat.assoc h' e f) ‚¨ù ap (category_struct.comp h') He ‚¨ù (is_precat.assoc h' e g)‚Åª¬π,
    have Hh'f : h' = fork_lift (fork.of_i (h' ‚â´ e) Hh'e), from 
      fork_lift_uniq (fork.of_i (h' ‚â´ e) Hh'e) h' rfl,
    rwr Hhf, rwr Hh'f, 
    let F : Œ† (h'': d ‚ü∂ a), (h'' ‚â´ f = h'' ‚â´ g) -> (d ‚ü∂ equalizer f g) := 
                                                     (Œª h'' p, fork_lift (fork.of_i h'' p)),
    change F (h ‚â´ e) Hhe = F (h' ‚â´ e) Hh'e, fapply apd011 F, 
    exact Hm, apply pathover_of_tr_eq, exact is_set.elim _ _ }
end  


/- The full subcategory on a subtype of a category with limits has limits if the limit
   of a diagram of objects of the subtype is also in the subtype. -/
@[hott]
def limit_closed_subtype {J : Type _} [H : is_strict_cat J] {C : Type u} [is_cat.{v} C]   
  (P : C -> trunctype.{0} -1) (F : J ‚•§ (sigma.subtype (Œª c : C, ‚Ü•(P c)))) :=
‚àÄ (lc : limit_cone (embed F)), (P lc.cone.X).carrier

@[hott] 
def emb_cone {J : Type _} [H : is_strict_cat J] {C : Type u} [is_cat.{v} C]   
  {P : C -> trunctype.{0} -1} {F : J ‚•§ (sigma.subtype (Œª c : C, ‚Ü•(P c)))} 
  (s : cone F) : cone (embed F) :=
begin
  fapply cone.mk, 
  { exact s.X.1 },
  { fapply nat_trans.mk,
    { intro j, exact s.œÄ.app j },
    { intros j k f, exact s.œÄ.naturality f } }
end  

@[hott]
def subcat_limit_cone {J : Type _} [H : is_strict_cat J] {C : Type u} [is_cat.{v} C]   
  {P : C -> trunctype.{0} -1} {F : J ‚•§ (sigma.subtype (Œª c : C, ‚Ü•(P c)))} 
  (lc : limit_cone (embed F)) (lim_clos : (P lc.cone.X).carrier) : 
  limit_cone F :=
begin
  fapply limit_cone.mk,
  { fapply cone.mk,
    { exact ‚ü®lc.cone.X, lim_clos‚ü© },
    { fapply nat_trans.mk, 
      { intro j, exact lc.cone.œÄ.app j },
      { intros j k f, exact lc.cone.œÄ.naturality f } } },
  { fapply is_limit.mk,
    { intro s, fapply cone_map.mk,
      { exact (lc.is_limit.lift (emb_cone s)).v_lift },
      { intro j, exact (lc.is_limit.lift (emb_cone s)).fac j } },
    { intros s m, 
      exact lc.is_limit.uniq (emb_cone s) (cone_map.mk m.v_lift (Œª j, m.fac j)) } }
end  

@[hott, instance]
def subcat_has_limit {J : Type _} [H : is_strict_cat J] {C : Type u} [is_cat.{v} C]   
  {P : C -> trunctype.{0} -1} {F : J ‚•§ (sigma.subtype (Œª c : C, ‚Ü•(P c)))} 
  [has_limit (embed F)] (lim_clos : limit_closed_subtype P F) : has_limit F :=
has_limit.mk (subcat_limit_cone (get_limit_cone (embed F)) 
             (lim_clos (get_limit_cone (embed F))))

@[hott, instance]
def subcat_has_limits_of_shape {J : Type _} [H : is_strict_cat J] {C : Type u} [is_cat.{v} C]   
  {P : C -> trunctype.{0} -1} [has_limits_of_shape J C] 
  (lim_clos : ‚àÄ F : J ‚•§ (sigma.subtype (Œª c : C, ‚Ü•(P c))), 
                                                  @limit_closed_subtype J _ _ _ P F) : 
  has_limits_of_shape J (sigma.subtype (Œª c : C, ‚Ü•(P c))) :=
has_limits_of_shape.mk (Œª F, subcat_has_limit (lim_clos F))     

@[hott, instance]
def subcat_has_products {C : Type u} [is_cat.{v} C] {P : C -> trunctype.{0} -1} 
  [has_products C] 
  (lim_clos : ‚àÄ (J : Set) (F : (discrete J) ‚•§ (sigma.subtype (Œª c : C, ‚Ü•(P c)))), 
                                  limit_closed_subtype P F) : 
  has_products (sigma.subtype (Œª c : C, ‚Ü•(P c))) :=
‚ü®Œª J : Set, @subcat_has_limits_of_shape (discrete J) _ _ _ _ 
             (has_limits_of_shape_of_has_products J C) (lim_clos J)‚ü©

/- We introduce the terminal object in a category together with some of its properties; 
  it exists if the category has limits. -/
@[hott]
structure terminal (C : Type u) [is_cat.{v} C] := 
  (star : C)
  (map : Œ† (c : C), c ‚ü∂ star)
  (uniq : Œ† {c : C} (f g : c ‚ü∂ star), f = g)

@[hott]
class has_terminal (C : Type u) [is_cat.{v} C] := 
  (str : terminal C) 

@[hott] 
def terminal_obj (C : Type u) [is_cat.{v} C] [H : has_terminal C] : C :=
  H.str.star

@[hott]
def terminal_map {C : Type u} [is_cat.{v} C] [H : has_terminal C] (c : C) :=
  H.str.map c

@[hott, instance]
def has_terminal_of_has_product (C : Type u) [is_cat.{v} C] 
  [H : has_product (empty_map.{u u} C)] : has_terminal C :=
begin
  apply has_terminal.mk, fapply terminal.mk,
  { exact @pi_obj _ _ _ (empty_map C) H },
  { intro c, apply pi.lift, intro j, hinduction j },
  { intros c f g, 
    let cc := @fan.mk _ C _ (empty_map.{u u} C) c (Œª j : false, false.rec _ j),
    let mcf : cone_map cc (get_limit_cone (discrete.functor (empty_map C))).cone := 
      begin fapply cone_map.mk, exact f, exact (Œª j : false, false.rec _ j) end,
    let mcg : cone_map cc (get_limit_cone (discrete.functor (empty_map C))).cone := 
      begin fapply cone_map.mk, exact g, exact (Œª j : false, false.rec _ j) end,
    change mcf.v_lift = mcg.v_lift, 
    let p := (get_limit_cone (discrete.functor (empty_map.{u u} C))).is_limit.uniq, 
    rwr p cc mcf, rwr p cc mcg }
end

@[hott]
def terminal_map_is_mono (C : Type u) [is_cat.{v} C] [H : has_terminal C] {c : C} :
  Œ† (f : terminal_obj C ‚ü∂ c), is_mono f :=
begin intros f d g‚ÇÅ g‚ÇÇ p, exact H.str.uniq g‚ÇÅ g‚ÇÇ end

@[hott]
def term_subobj (C : Type u) [is_cat.{v} C] [H : has_terminal C] {c : C} (f : terminal_obj C ‚ü∂ c) :
  subobject c := (subobject.mk (terminal_obj C) f (terminal_map_is_mono C f))

end categories.limits

end hott