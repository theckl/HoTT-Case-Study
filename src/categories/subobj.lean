import sets.algebra init2 types2 sets.axioms categories.basic

universes v v' v'' v''' u u' u'' u''' w 
hott_theory

namespace hott
open hott.eq hott.sigma hott.set hott.subset hott.is_trunc 
     hott.is_equiv hott.trunc hott.precategories hott.categories

/- In a category `C` we can define a subobject of an object `c` as a monomorphism `a ‚ü∂ c`. Two 
   such subobjects are equal if and only if there is an isomorphism between the sources of the 
   monomorphisms factorizing the monomorphisms. Therefore in HoTT categories, it is not necessary 
   to define subobjects as isomorphism classes. -/
@[hott]
def is_mono {C : Category} {c‚ÇÅ c‚ÇÇ : C} (f : c‚ÇÅ ‚ü∂ c‚ÇÇ) :=
  Œ† (d : C) (g‚ÇÅ g‚ÇÇ : d ‚ü∂ c‚ÇÅ), g‚ÇÅ ‚â´ f = g‚ÇÇ ‚â´ f -> g‚ÇÅ = g‚ÇÇ

@[hott, instance]
def is_mono_is_prop {C : Category} {c‚ÇÅ c‚ÇÇ : C} (f : c‚ÇÅ ‚ü∂ c‚ÇÇ) : 
  is_prop (is_mono f) :=
begin apply is_prop_dprod, intro d, apply_instance end 

@[hott]
def is_mono_is_trans {C : Category} {c‚ÇÅ c‚ÇÇ c‚ÇÉ : C} {f : c‚ÇÅ ‚ü∂ c‚ÇÇ} 
  {g : c‚ÇÇ ‚ü∂ c‚ÇÉ} : is_mono f -> is_mono g -> is_mono (f ‚â´ g) :=
begin 
  intros Hf Hg d h‚ÇÅ h‚ÇÇ, rwr <- is_precat.assoc, rwr <- is_precat.assoc, 
  intro H, exact Hf d h‚ÇÅ h‚ÇÇ (Hg d (h‚ÇÅ ‚â´ f) (h‚ÇÇ ‚â´ f) H) end  

@[hott]
def isos_are_mono {C : Category} {c‚ÇÅ c‚ÇÇ : C} (i : c‚ÇÅ ‚âÖ c‚ÇÇ) : is_mono i.hom :=  
  assume d g‚ÇÅ g‚ÇÇ eq_comp, 
  calc g‚ÇÅ = g‚ÇÅ ‚â´ ùüô c‚ÇÅ : by rwr is_precat.comp_id
       ... = g‚ÇÅ ‚â´ (i.hom ‚â´ i.inv) : by rwr iso.l_inv
       ... = (g‚ÇÅ ‚â´ i.hom) ‚â´ i.inv : by rwr is_precat.assoc
       ... = (g‚ÇÇ ‚â´ i.hom) ‚â´ i.inv : by rwr eq_comp
       ... = g‚ÇÇ : by rwr is_precat.assoc; rwr iso.l_inv; rwr is_precat.comp_id   

@[hott]
structure hom_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} 
  (Hf : is_mono f) {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) :=
(hom_obj : d‚ÇÅ ‚ü∂ d‚ÇÇ)
(fac : hom_obj ‚â´ g = f)

@[hott, instance]
def is_prop_hom_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} (Hf : is_mono f)
  {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) : is_prop (hom_of_monos Hf Hg) :=
begin 
  apply is_prop.mk, intros hm‚ÇÅ hm‚ÇÇ, hinduction hm‚ÇÅ with h‚ÇÅ fac‚ÇÅ, hinduction hm‚ÇÇ with h‚ÇÇ fac‚ÇÇ, 
  fapply apd011 (hom_of_monos.mk Hf Hg), 
  { apply Hg, exact fac‚ÇÅ ‚¨ù fac‚ÇÇ‚Åª¬π },
  { apply pathover_of_tr_eq, exact is_set.elim _ _ } 
end  

@[hott]
structure iso_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} (Hf : is_mono f)
  {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) :=
(iso_obj : d‚ÇÅ ‚âÖ d‚ÇÇ)
(fac : iso_obj.hom ‚â´ g = f) 

@[hott]
def iso_of_monos_eq {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} {Hf : is_mono f}
  {g : d‚ÇÇ ‚ü∂ c} {Hg : is_mono g} (im‚ÇÅ im‚ÇÇ : iso_of_monos Hf Hg) : 
  im‚ÇÅ.iso_obj = im‚ÇÇ.iso_obj -> im‚ÇÅ = im‚ÇÇ :=
begin 
  hinduction im‚ÇÅ with iso_obj‚ÇÅ fac‚ÇÅ, hinduction im‚ÇÇ with iso_obj‚ÇÇ fac‚ÇÇ, hsimp, 
  intro p, fapply apd011 (iso_of_monos.mk Hf Hg), assumption,
  apply pathover_of_tr_eq, exact is_set.elim _ _ 
end 

@[hott]
def homs_eqv_iso_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} (Hf : is_mono f)
  {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) : 
  (hom_of_monos Hf Hg) √ó (hom_of_monos Hg Hf) ‚âÉ iso_of_monos Hf Hg :=
begin 
  fapply equiv.mk, 
  { intro homs, let sh‚ÇÅ := homs.1, let sh‚ÇÇ := homs.2, fapply iso_of_monos.mk, 
    { fapply iso.mk, 
      { exact sh‚ÇÅ.hom_obj },
      { exact sh‚ÇÇ.hom_obj },
      { apply Hg d‚ÇÇ (sh‚ÇÇ.hom_obj ‚â´ sh‚ÇÅ.hom_obj) (ùüô d‚ÇÇ), rwr is_precat.assoc, 
        rwr sh‚ÇÅ.fac, rwr sh‚ÇÇ.fac, hsimp },
      { apply Hf d‚ÇÅ (sh‚ÇÅ.hom_obj ‚â´ sh‚ÇÇ.hom_obj) (ùüô d‚ÇÅ), rwr is_precat.assoc, 
        rwr sh‚ÇÇ.fac, rwr sh‚ÇÅ.fac, hsimp } },
    { hsimp, rwr sh‚ÇÅ.fac } },
  { fapply adjointify, 
    { intro i, fapply pair, 
      { fapply hom_of_monos.mk, exact i.iso_obj.hom, exact i.fac },
      { fapply hom_of_monos.mk, exact i.iso_obj.inv, rwr iso_move_lr _ _ _ i.fac } },
    { intro im, hinduction im with i fac, apply iso_of_monos_eq _ _, 
      { apply hom_eq_to_iso_eq, hsimp } },
    { intro hm, hinduction hm with hm‚ÇÅ hm‚ÇÇ, 
      hinduction hm‚ÇÅ with hom_obj‚ÇÅ fac‚ÇÅ, hinduction hm‚ÇÇ with hom_obj‚ÇÇ fac‚ÇÇ, fapply prod.prod_eq,
      { fapply apd011 (hom_of_monos.mk Hf Hg), hsimp, 
        apply pathover_of_tr_eq, exact is_set.elim _ _ },
      { fapply apd011 (hom_of_monos.mk Hg Hf), hsimp, 
        apply pathover_of_tr_eq, exact is_set.elim _ _ } } }
end  

@[hott, instance]
def is_prop_iso_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} (Hf : is_mono f)
  {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) : is_prop (iso_of_monos Hf Hg) :=
begin apply is_trunc_equiv_closed -1 (homs_eqv_iso_of_monos Hf Hg), apply_instance end

@[hott]
structure subobject {C : Category} (c : C) :=
  (obj : C)
  (hom : obj ‚ü∂ c)
  (is_mono : is_mono hom)  

@[hott]
def subobject_eta {C : Category} {c : C} (so : subobject c) :
  so = subobject.mk so.obj so.hom so.is_mono :=
begin hinduction so, refl end   

@[hott]
def subobject_eta_eq {C : Category} {c : C} (obj : C) (hom : obj ‚ü∂ c) 
  (is_mono : is_mono hom) : subobject_eta (subobject.mk obj hom is_mono) = idp :=
rfl  

@[hott] 
def subobject_eq_idp {C : Category} {c : C} {s : subobject c} 
  (p : s.obj = s.obj) (q : s.hom =[p; Œª d, d ‚ü∂ c] s.hom) 
  (r : s.is_mono =[apd011 (Œª (a : C) (b : ‚Ü•(a ‚ü∂ c)), is_mono b) p q; id] s.is_mono) :
  p = idp -> apd0111 subobject.mk p q r = idp :=
begin 
  intro Hp, 
  have Hq : q =[Hp; Œª p' : s.obj = s.obj, s.hom =[p'; Œª d, d ‚ü∂ c] s.hom] idpatho s.hom, from 
    begin apply pathover_of_tr_eq, exact set_po_eq _ _ end,
  have H : is_prop (s.is_mono =[idp; id] s.is_mono), from 
    begin 
      apply is_trunc_equiv_closed_rev -1 (pathover_equiv_tr_eq _ _ _), exact is_trunc_eq -1 _ _
     end,  
  have Hr : r =[apd011 (Œª (x : s.obj = s.obj) (y : s.hom =[x; Œª d, d ‚ü∂ c] s.hom), 
                          apd011 (Œª (obj : C) (hom : obj ‚ü∂ c), is_mono hom) x y) Hp Hq;
                Œª Hf : is_mono s.hom = is_mono s.hom, s.is_mono =[Hf; id] s.is_mono] 
                                                                      idpatho s.is_mono, from 
    begin apply pathover_of_tr_eq, exact @is_prop.elim _ H _ _ end, 
  rwr @apd0111_eq _ _ _ (Œª (obj : C) (hom : obj ‚ü∂ c), is_mono hom) _ _ _ _ _ _ _ _ _ _ _ _ _ 
                                                                                       Hp Hq Hr 
end   

/- A homomorphism between subobjects compatible with the injections is itself an injection. Hence,
   homomorphisms between subobjects in both ways imply an isomorphism of subobjects and therefore
   equality. -/
@[hott]
def subobject_hom {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :=
  hom_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono

@[hott, instance]
def subobject_hom_is_prop {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :
  is_prop (subobject_hom s‚ÇÅ s‚ÇÇ) :=
begin change is_prop (hom_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono), apply_instance end    

@[hott]
def equal_subobj_to_iso_mono {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :
  s‚ÇÅ = s‚ÇÇ -> iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono :=
begin 
  intro p, fapply iso_of_monos.mk, 
  exact (idtoiso (ap subobject.obj p)), 
  hinduction p, hsimp 
end  

@[hott] 
def idp_subobj_to_iso_mono {C : Category} {c : C} (s : subobject c) :
  equal_subobj_to_iso_mono s s idp = iso_of_monos.mk s.is_mono s.is_mono (id_iso s.obj) 
                                                     (is_precat.id_comp s.hom) :=
begin apply iso_of_monos_eq, change idtoiso idp = id_iso s.obj, rwr idtoiso_refl_eq end                                                     

@[hott]
def iso_mono_to_equal_subobj {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :
  iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono -> s‚ÇÅ = s‚ÇÇ :=
assume im, (subobject_eta s‚ÇÅ) ‚¨ù  
begin 
  fapply apd0111 subobject.mk, 
  { exact category.isotoid im.iso_obj },
  { apply pathover_of_tr_eq, 
    change idtoiso‚Åª¬π·∂† im.iso_obj ‚ñ∏[Œª (d : C), ‚Ü•(d ‚ü∂ c)] s‚ÇÅ.hom = s‚ÇÇ.hom, 
    rwr iso_hom_tr_comp, 
    calc (im.iso_obj)‚Åª¬π ∞ ‚â´ s‚ÇÅ.hom = (im.iso_obj)‚Åª¬π ∞ ‚â´ im.iso_obj.hom ‚â´ s‚ÇÇ.hom : 
                                                                           by rwr im.fac
         ... = ((im.iso_obj)‚Åª¬π ∞ ‚â´ im.iso_obj.hom) ‚â´ s‚ÇÇ.hom : 
               by rwr is_precat.assoc
         ... = ùüô s‚ÇÇ.obj ‚â´ s‚ÇÇ.hom : by rwr iso.r_inv 
         ... = s‚ÇÇ.hom : by rwr is_precat.id_comp },
  { apply pathover_of_tr_eq, apply eq_of_homotopy3, intros d g‚ÇÅ g‚ÇÇ, 
    apply eq_of_homotopy, intro comp_eq, exact is_prop.elim _ _ } 
end 
‚¨ù (subobject_eta s‚ÇÇ)‚Åª¬π  

@[hott]
def iso_mono_to_equal_subobj_iso {C : Category} {c : C} {s‚ÇÅ s‚ÇÇ : subobject c} 
  (im : iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono) : 
  ap subobject.obj (iso_mono_to_equal_subobj s‚ÇÅ s‚ÇÇ im) = category.isotoid im.iso_obj :=
begin
  hinduction s‚ÇÅ with obj‚ÇÅ hom‚ÇÅ is_mono‚ÇÅ, hinduction s‚ÇÇ with obj‚ÇÇ hom‚ÇÇ is_mono‚ÇÇ,
  change ap subobject.obj ((subobject_eta _) ‚¨ù (apd0111 subobject.mk _ _ _) ‚¨ù _) = _, 
  rwr subobject_eta_eq, rwr subobject_eta_eq, rwr idp_con, rwr idp_inv, rwr con_idp,
  let HP : Œ† (obj : C) (hom : obj ‚ü∂ c) (is_mono : is_mono hom), 
                                     subobject.obj (subobject.mk obj hom is_mono) = obj := 
      begin intros obj hom is_mono, exact idp end, 
  rwr ap_apd0111 subobject.mk _ _ _ subobject.obj HP, 
  change idp ‚¨ù category.isotoid im.iso_obj ‚¨ù idp‚Åª¬π = _, rwr idp_con   
end    

@[hott]
def equal_subobj_eqv_iso_mono {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :
  s‚ÇÅ = s‚ÇÇ ‚âÉ iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono :=
begin
  fapply equiv.mk,
  { exact equal_subobj_to_iso_mono s‚ÇÅ s‚ÇÇ },
  { fapply adjointify,
    { exact iso_mono_to_equal_subobj s‚ÇÅ s‚ÇÇ },
    { hinduction s‚ÇÅ with obj‚ÇÅ hom‚ÇÅ is_mono‚ÇÅ, hinduction s‚ÇÇ with obj‚ÇÇ hom‚ÇÇ is_mono‚ÇÇ,
      intro im, hinduction im with iso_obj fac, apply iso_of_monos_eq _ _, hsimp,
      change idtoiso (ap subobject.obj _) = _, rwr iso_mono_to_equal_subobj_iso,
      change idtoiso (idtoiso‚Åª¬π·∂† _) = _, rwr category.idtoiso_rinv },
    { intro p, hinduction p, --hinduction s‚ÇÅ with obj‚ÇÅ hom‚ÇÅ is_mono‚ÇÅ, 
      rwr idp_subobj_to_iso_mono, 
      change (subobject_eta _) ‚¨ù (apd0111 subobject.mk (category.isotoid (id_iso s‚ÇÅ.obj)) _ _) ‚¨ù 
                                                                                              _ = _, 
      apply con_eq_of_eq_con_inv, apply con_eq_of_eq_inv_con, rwr idp_con, 
      rwr con.right_inv, apply subobject_eq_idp, rwr isotoid_id_refl } }
end    

/- The subobjects of an object in a HoTT-category form a set, so a HoTT-category is well-powered. -/
@[hott, instance]
def subobject_is_set {C : Category} {c : C} : is_set (subobject c) :=
begin 
  apply is_trunc_succ_intro, intros s‚ÇÅ s‚ÇÇ, 
  apply is_trunc_equiv_closed_rev -1 (equal_subobj_eqv_iso_mono s‚ÇÅ s‚ÇÇ), 
  apply is_trunc_equiv_closed -1 (homs_eqv_iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono), 
  apply_instance 
end

/- The subobjects of an object, together with their monomorphism-preserving homomorphisms
   defined in [categories.basic], form a category. -/  
@[hott, instance]
def subobject_has_hom {C : Category} {c : C} : has_hom (subobject c) :=
  has_hom.mk (Œª a b : subobject c, Set.mk (subobject_hom a b) (is_trunc_succ _ -1))

@[hott]
def id_subobject {C : Category} {c : C} (a : subobject c) : subobject_hom a a :=
  begin fapply hom_of_monos.mk a.is_mono a.is_mono, exact ùüô a.obj, hsimp end  

@[hott] 
def comp_subobject {C : Category} {c : C} (a‚ÇÅ a‚ÇÇ a‚ÇÉ : subobject c) :
  subobject_hom a‚ÇÅ a‚ÇÇ -> subobject_hom a‚ÇÇ a‚ÇÉ -> subobject_hom a‚ÇÅ a‚ÇÉ :=
begin 
  intros f g, fapply hom_of_monos.mk a‚ÇÅ.is_mono a‚ÇÉ.is_mono, exact f.hom_obj ‚â´ g.hom_obj, 
  rwr is_precat.assoc, rwr g.fac, rwr f.fac 
end  

@[hott, instance]
def subobject_cat_struct {C : Category} {c : C} : 
  category_struct (subobject c) :=
category_struct.mk id_subobject comp_subobject

@[hott, instance]
def subobject_is_precat {C : Category} {c : C} : 
  is_precat (subobject c) :=
have ic : Œ† (a b : subobject c) (f : a ‚ü∂ b), ùüô a ‚â´ f = f, from 
  assume a b f, by exact is_prop.elim _ _,
have ci : Œ† (a b : subobject c) (f : a ‚ü∂ b), f ‚â´ ùüô b = f, from 
  assume a b f, by exact is_prop.elim _ _,
have as : Œ† (a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÑ : subobject c) (f : a‚ÇÅ ‚ü∂ a‚ÇÇ) (g : a‚ÇÇ ‚ü∂ a‚ÇÉ) (h : a‚ÇÉ ‚ü∂ a‚ÇÑ),
             (f ‚â´ g) ‚â´ h = f ‚â´ (g ‚â´ h), from 
  assume a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÑ f g h, by exact is_prop.elim _ _,
is_precat.mk ic ci as  

@[hott]
def iso_of_monos_to_iso {C : Category} {c : C} (a b : subobject c) :
  (iso_of_monos a.is_mono b.is_mono) -> (a ‚âÖ b) :=
begin 
  intro im, fapply iso.mk, 
  { fapply hom_of_monos.mk, exact im.iso_obj.hom, exact im.fac }, 
  { fapply hom_of_monos.mk, exact im.iso_obj.inv, apply eq.inverse, apply iso_move_lr, 
    exact im.fac },
  exact is_prop.elim _ _, exact is_prop.elim _ _ 
end

@[hott]
def iso_to_iso_of_monos {C : Category} {c : C} (a b : subobject c) :
  (a ‚âÖ b) -> (iso_of_monos a.is_mono b.is_mono) :=
begin 
  intro i, fapply iso_of_monos.mk, 
  { fapply iso.mk, exact i.hom.hom_obj, exact i.inv.hom_obj, 
    exact ap hom_of_monos.hom_obj i.r_inv, exact ap hom_of_monos.hom_obj i.l_inv },
  { exact i.hom.fac }
end    

@[hott]
def iso_of_monos_eqv_iso {C : Category} {c : C} (a b : subobject c) :
  (iso_of_monos a.is_mono b.is_mono) ‚âÉ (a ‚âÖ b) :=
begin 
  fapply equiv.mk,
  { exact iso_of_monos_to_iso a b },
  { fapply adjointify, 
    { exact iso_to_iso_of_monos a b },
    { intro i, apply hom_eq_to_iso_eq, exact is_prop.elim _ _ },
    { intro i, exact @is_prop.elim _ 
              (is_prop_iso_of_monos a.is_mono b.is_mono) _ _ } }
end  

@[hott]
def subobj_idtoiso {C : Category} {c : C} (a b : subobject c) : 
  @idtoiso _ _ a b = (iso_of_monos_eqv_iso a b).to_fun ‚àò 
                     (equal_subobj_eqv_iso_mono a b).to_fun :=
begin apply eq_of_homotopy, intro p, apply hom_eq_to_iso_eq, exact is_prop.elim _ _ end                       

@[hott, instance]
def subobject_is_cat {C : Category} {c : C} : 
  is_cat (subobject c) :=
begin apply is_cat.mk, intros a b, rwr subobj_idtoiso a b, apply_instance end    

@[hott]
def subobject_Category {C : Category} (c : C) : Category :=
  Category.mk (subobject c) subobject_is_cat

@[hott]
def subobj_antisymm {C : Category} {c : C} (a b : subobject_Category c) : 
  (a ‚ü∂ b) -> (b ‚ü∂ a) -> (a = b) :=
begin 
  intros i j , 
  have iso_ab : a ‚âÖ b, from 
    begin 
      fapply iso.mk, exact i, exact j, 
      exact @is_prop.elim _ (subobject_hom_is_prop b b) _ _, 
      exact @is_prop.elim _ (subobject_hom_is_prop a a) _ _ 
    end,  
  exact category.isotoid iso_ab 
end  

@[hott]
def subobj_trans {C : Category} {c : C} (a : subobject c) 
  (b : subobject a.obj) : subobject c :=
subobject.mk b.obj (b.hom ‚â´ a.hom) (is_mono_is_trans b.is_mono a.is_mono) 

/- The category of subobjects always has a top element. -/
@[hott]
def top_subobject {C : Category} (c : C) : subobject c := 
  subobject.mk c (ùüô c) (isos_are_mono (id_iso c))

@[hott]
def top_subobj_prop {C : Category} {c : C} : 
  Œ† (a : subobject c), a ‚ü∂ top_subobject c := 
begin intro a, fapply hom_of_monos.mk, exact a.hom, hsimp end   

/- We can define images of homomorphisms as subobjects of their codomain satisfying a 
   minimal property. Note that the factoring homomorphism is unique as the inclusion 
   homomorphism is a monomorphism. -/
@[hott]
structure cat_image {C : Category} {c d : C} (f : c ‚ü∂ d) :=
  (subobj : subobject d)
  (fac : Œ£ f' : c ‚ü∂ subobj.obj, f' ‚â´ subobj.hom = f)
  (univ : Œ† (a : subobject d), (Œ£ f' : c ‚ü∂ a.obj, f' ‚â´ a.hom = f) -> (subobj ‚ü∂ a))

@[hott] 
def subobject_fac_is_unique {C : Category} {c d : C} (f : c ‚ü∂ d) 
  (a : subobject d) : Œ† fac‚ÇÅ fac‚ÇÇ : (Œ£ (f' : c ‚ü∂ a.obj), f' ‚â´ a.hom = f), fac‚ÇÅ = fac‚ÇÇ :=
begin 
  intros fac‚ÇÅ fac‚ÇÇ, fapply sigma.sigma_eq, 
  { fapply a.is_mono, exact fac‚ÇÅ.2 ‚¨ù fac‚ÇÇ.2‚Åª¬π }, 
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ } 
end

@[hott, instance] 
def subobject_fac_is_prop {C : Category} {c d : C} (f : c ‚ü∂ d) 
  (a : subobject d) : is_prop (Œ£ f' : c ‚ü∂ a.obj, f' ‚â´ a.hom = f) :=
is_prop.mk (subobject_fac_is_unique f a)  

@[hott]
class has_image {C : Category} {c d : C} (f : c ‚ü∂ d) :=
  (exists_im : ‚à•cat_image f‚à•)

@[hott]
def cat_image_is_unique {C : Category} {c d : C} (f : c ‚ü∂ d) :
  Œ† im‚ÇÅ im‚ÇÇ : cat_image f, im‚ÇÅ = im‚ÇÇ :=
begin
  intros im‚ÇÅ im‚ÇÇ, 
  hinduction im‚ÇÅ with subobj‚ÇÅ fac‚ÇÅ univ‚ÇÅ, hinduction im‚ÇÇ with subobj‚ÇÇ fac‚ÇÇ univ‚ÇÇ, 
  fapply apdd2 cat_image.mk, 
  { fapply subobj_antisymm, exact univ‚ÇÅ subobj‚ÇÇ fac‚ÇÇ, exact univ‚ÇÇ subobj‚ÇÅ fac‚ÇÅ },
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ },
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ }
end  

@[hott, instance]
def cat_image_is_prop {C : Category} {c d : C} (f : c ‚ü∂ d) : 
  is_prop (cat_image f) :=
is_prop.mk (cat_image_is_unique f)  

@[hott, reducible]
def hom.image {C : Category} {c d : C} (f : c ‚ü∂ d) [has_image f] : 
  subobject d :=  
(@untrunc_of_is_trunc _ _ (cat_image_is_prop f) (has_image.exists_im f)).subobj

@[hott, reducible]
def hom_to_image {C : Category} {c d : C} (f : c ‚ü∂ d) [has_image f] :
  c ‚ü∂ (hom.image f).obj := 
(untrunc_of_is_trunc (has_image.exists_im f)).fac.1  

@[hott]
def hom_to_image_eq {C : Category} {c d : C} (f : c ‚ü∂ d) [has_image f] :
  hom_to_image f ‚â´ (hom.image f).hom = f := 
(untrunc_of_is_trunc (has_image.exists_im f)).fac.2 

@[hott]
def hom_image_univ {C : Category} {c d : C} (f : c ‚ü∂ d) [has_image f] :
  Œ† (a : subobject d) (f' : c ‚ü∂ a.obj), f' ‚â´ a.hom = f -> (hom.image f ‚ü∂ a) :=
assume a f' p, (untrunc_of_is_trunc (has_image.exists_im f)).univ a ‚ü®f', p‚ü© 

@[hott, instance]
def subobj_has_im {C : Category} {c : C} (b : subobject c) :
  has_image b.hom :=
have im_b : cat_image b.hom, from 
  cat_image.mk b (sigma.mk (ùüô b.obj) (is_precat.id_comp b.hom)) 
               (Œª a m, hom_of_monos.mk _ _ m.1 m.2),  
has_image.mk (tr im_b)

@[hott]
def subobj_is_im {C : Category} {c : C} (b : subobject c) :
  hom.image b.hom = b := idp  

@[hott]
def im_incl {C : Category} {a b c : C} (f : a ‚ü∂ b) (g : b ‚ü∂ c) 
  [has_image (f ‚â´ g)] [has_image g] : hom.image (f ‚â´ g) ‚ü∂ hom.image g :=
begin 
  fapply cat_image.univ, fapply sigma.mk, 
  { exact f ‚â´ hom_to_image g }, 
  { rwr is_precat.assoc, rwr hom_to_image_eq g }
end  

@[hott]
class has_images (C : Category) :=
  (has_im : Œ† {c d : C} (f : c ‚ü∂ d), has_image f)

@[hott, instance]
def has_image_of_has_images {C : Category} [has_images C] {c d : C} 
  (f : c ‚ü∂ d) : has_image f :=
has_images.has_im f

end hott