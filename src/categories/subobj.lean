import sets.algebra init2 types2 sets.axioms categories.examples

universes v v' v'' v''' u u' u'' u''' w 
hott_theory

namespace hott
open hott.eq hott.sigma hott.set hott.subset hott.is_trunc 
     hott.is_equiv hott.trunc hott.precategories hott.categories

/- In a category `C` we can define a subobject of an object `c` as a monomorphism `a ‚ü∂ c`. Two 
   such subobjects are equal if and only if there is an isomorphism between the sources of the 
   monomorphisms factorizing the monomorphisms. Therefore in HoTT categories, it is not necessary 
   to define subobjects as isomorphism classes. -/
@[hott]  --[GEVE]
def is_mono {C : Category} {c‚ÇÅ c‚ÇÇ : C} (f : c‚ÇÅ ‚ü∂ c‚ÇÇ) :=
  Œ† (d : C) (g‚ÇÅ g‚ÇÇ : d ‚ü∂ c‚ÇÅ), g‚ÇÅ ‚â´ f = g‚ÇÇ ‚â´ f -> g‚ÇÅ = g‚ÇÇ

@[hott]
def is_epi {C : Category} {c‚ÇÅ c‚ÇÇ : C} (f : c‚ÇÅ ‚ü∂ c‚ÇÇ) :=
  Œ† (d : C) (g‚ÇÅ g‚ÇÇ : c‚ÇÇ ‚ü∂ d), f ‚â´ g‚ÇÅ = f ‚â´ g‚ÇÇ -> g‚ÇÅ = g‚ÇÇ

@[hott, instance]
def is_mono_is_prop {C : Category} {c‚ÇÅ c‚ÇÇ : C} (f : c‚ÇÅ ‚ü∂ c‚ÇÇ) : 
  is_prop (is_mono f) :=
begin apply is_prop_dprod, intro d, apply_instance end 

@[hott]
def is_mono_is_trans {C : Category} {c‚ÇÅ c‚ÇÇ c‚ÇÉ : C} {f : c‚ÇÅ ‚ü∂ c‚ÇÇ} 
  {g : c‚ÇÇ ‚ü∂ c‚ÇÉ} : is_mono f -> is_mono g -> is_mono (f ‚â´ g) :=
begin 
  intros Hf Hg d h‚ÇÅ h‚ÇÇ, rwr <- is_precat.assoc, rwr <- is_precat.assoc, 
  intro H, exact Hf d h‚ÇÅ h‚ÇÇ (Hg d (h‚ÇÅ ‚â´ f) (h‚ÇÇ ‚â´ f) H) end  

@[hott]
def isos_are_mono {C : Category} {c‚ÇÅ c‚ÇÇ : C} (i : c‚ÇÅ ‚âÖ c‚ÇÇ) : is_mono i.hom :=  
  assume d g‚ÇÅ g‚ÇÇ eq_comp, 
  calc g‚ÇÅ = g‚ÇÅ ‚â´ ùüô c‚ÇÅ : by rwr is_precat.comp_id
       ... = g‚ÇÅ ‚â´ (i.hom ‚â´ i.ih.inv) : by rwr is_iso.l_inv
       ... = (g‚ÇÅ ‚â´ i.hom) ‚â´ i.ih.inv : by rwr is_precat.assoc
       ... = (g‚ÇÇ ‚â´ i.hom) ‚â´ i.ih.inv : by rwr eq_comp
       ... = g‚ÇÇ : by rwr is_precat.assoc; rwr is_iso.l_inv; rwr is_precat.comp_id   

@[hott]
structure hom_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} 
  (Hf : is_mono f) {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) :=
(hom_obj : d‚ÇÅ ‚ü∂ d‚ÇÇ)
(fac : hom_obj ‚â´ g = f)

@[hott]
def hom_of_monos_is_mono {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} 
  {Hf : is_mono f} {g : d‚ÇÇ ‚ü∂ c} {Hg : is_mono g} (hm : hom_of_monos Hf Hg) :
  is_mono hm.hom_obj :=
begin 
  intros d h‚ÇÅ h‚ÇÇ p, apply Hf, rwr <- hm.fac, 
  rwr <- is_precat.assoc, rwr <- is_precat.assoc, rwr p 
end

@[hott, instance]
def is_prop_hom_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} (Hf : is_mono f)
  {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) : is_prop (hom_of_monos Hf Hg) :=
begin 
  apply is_prop.mk, intros hm‚ÇÅ hm‚ÇÇ, hinduction hm‚ÇÅ with h‚ÇÅ fac‚ÇÅ, hinduction hm‚ÇÇ with h‚ÇÇ fac‚ÇÇ, 
  fapply apd011 (hom_of_monos.mk Hf Hg), 
  { apply Hg, exact fac‚ÇÅ ‚¨ù fac‚ÇÇ‚Åª¬π },
  { apply pathover_of_tr_eq, exact is_set.elim _ _ } 
end  

@[hott]
structure iso_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} (Hf : is_mono f)
  {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) :=
(iso_obj : d‚ÇÅ ‚âÖ d‚ÇÇ)
(fac : iso_obj.hom ‚â´ g = f) 

@[hott]
def iso_of_monos_eq {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} {Hf : is_mono f}
  {g : d‚ÇÇ ‚ü∂ c} {Hg : is_mono g} (im‚ÇÅ im‚ÇÇ : iso_of_monos Hf Hg) : 
  im‚ÇÅ.iso_obj = im‚ÇÇ.iso_obj -> im‚ÇÅ = im‚ÇÇ :=
begin 
  hinduction im‚ÇÅ with iso_obj‚ÇÅ fac‚ÇÅ, hinduction im‚ÇÇ with iso_obj‚ÇÇ fac‚ÇÇ, hsimp, 
  intro p, fapply apd011 (iso_of_monos.mk Hf Hg), assumption,
  apply pathover_of_tr_eq, exact is_set.elim _ _ 
end 

@[hott]
def homs_eqv_iso_of_monos {C : Category.{u v}} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} (Hf : is_mono f)
  {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) : 
  (hom_of_monos Hf Hg) √ó (hom_of_monos Hg Hf) ‚âÉ iso_of_monos Hf Hg :=
begin 
  fapply equiv.mk, 
  { intro homs, let sh‚ÇÅ := homs.1, let sh‚ÇÇ := homs.2, fapply iso_of_monos.mk, 
    { fapply iso.mk, 
      { exact sh‚ÇÅ.hom_obj },
      { fapply is_iso.mk,
        { exact sh‚ÇÇ.hom_obj },
        { apply Hg d‚ÇÇ (sh‚ÇÇ.hom_obj ‚â´ sh‚ÇÅ.hom_obj) (ùüô d‚ÇÇ), rwr is_precat.assoc, 
        rwr sh‚ÇÅ.fac, rwr sh‚ÇÇ.fac, hsimp },
        { apply Hf d‚ÇÅ (sh‚ÇÅ.hom_obj ‚â´ sh‚ÇÇ.hom_obj) (ùüô d‚ÇÅ), rwr is_precat.assoc, 
        rwr sh‚ÇÇ.fac, rwr sh‚ÇÅ.fac, hsimp } } },
    { hsimp, rwr sh‚ÇÅ.fac } },
  { fapply adjointify, 
    { intro i, fapply pair, 
      { fapply hom_of_monos.mk, exact i.iso_obj.hom, exact i.fac },
      { fapply hom_of_monos.mk, exact i.iso_obj.ih.inv, rwr iso_move_lr _ _ _ i.fac } },
    { intro im, hinduction im with i fac, apply iso_of_monos_eq _ _, 
      { apply hom_eq_to_iso_eq, hsimp } },
    { intro hm, hinduction hm with hm‚ÇÅ hm‚ÇÇ, 
      hinduction hm‚ÇÅ with hom_obj‚ÇÅ fac‚ÇÅ, hinduction hm‚ÇÇ with hom_obj‚ÇÇ fac‚ÇÇ, fapply prod.prod_eq,
      { fapply apd011 (hom_of_monos.mk Hf Hg), hsimp, 
        apply pathover_of_tr_eq, exact is_set.elim _ _ },
      { fapply apd011 (hom_of_monos.mk Hg Hf), hsimp, 
        apply pathover_of_tr_eq, exact is_set.elim _ _ } } }
end  

@[hott, instance]
def is_prop_iso_of_monos {C : Category} {c d‚ÇÅ d‚ÇÇ: C} {f : d‚ÇÅ ‚ü∂ c} (Hf : is_mono f)
  {g : d‚ÇÇ ‚ü∂ c} (Hg : is_mono g) : is_prop (iso_of_monos Hf Hg) :=
begin apply is_trunc_equiv_closed -1 (homs_eqv_iso_of_monos Hf Hg), apply_instance end

@[hott]  --[GEVE]
def mono_is_faithful {C D : Category} {F : C ‚•§ D} [H : is_faithful_functor F] {c‚ÇÅ c‚ÇÇ: C} :
  Œ† (f : c‚ÇÅ ‚ü∂ c‚ÇÇ), is_mono (F.map f) -> is_mono f :=
begin 
  intros f mono_F, intros d g‚ÇÅ g‚ÇÇ p, apply H, apply mono_F,
  rwr <- F.map_comp, rwr <- F.map_comp, exact ap (precategories.functor.map F) p 
end 

@[hott]  --[GEVE]
structure subobject {C : Category} (c : C) :=
  (obj : C)
  (hom : obj ‚ü∂ c)
  (is_mono : is_mono hom)  

@[hott]
def subobject_eq {C : Category} {c : C} {s‚ÇÅ s‚ÇÇ : subobject c} :
  Œ† (p : s‚ÇÅ.obj = s‚ÇÇ.obj), s‚ÇÅ.hom =[p; Œª a : C, a ‚ü∂ c ] s‚ÇÇ.hom -> s‚ÇÅ = s‚ÇÇ :=
begin
  hinduction s‚ÇÅ with a‚ÇÅ h‚ÇÅ mono‚ÇÅ, hinduction s‚ÇÇ with a‚ÇÇ h‚ÇÇ mono‚ÇÇ,
  intros p q, fapply apd0111 subobject.mk, exact p, exact q, 
  apply pathover_of_tr_eq, exact is_prop.elim _ _
end

@[hott] 
def subobject_eq_idp {C : Category} {c : C} {s : subobject c} 
  {q : s.hom =[idp; Œª a : C, a ‚ü∂ c ] s.hom} :
  @subobject_eq C c s _ idp q = idp :=
begin
  have r : q = idpo, from begin apply is_prop.elim end,
  hinduction s with a h mono, rwr r, change apd0111 subobject.mk idp idpo _ = idp, 
  hsimp, refl
end

@[hott]
def subobject_eq_obj {C : Category} {c : C} {s‚ÇÅ s‚ÇÇ : subobject c} 
  {p : s‚ÇÅ.obj = s‚ÇÇ.obj} {q : s‚ÇÅ.hom =[p; Œª a : C, a ‚ü∂ c ] s‚ÇÇ.hom} :
  ap subobject.obj (subobject_eq p q) = p :=
begin
  hinduction s‚ÇÅ with a‚ÇÅ h‚ÇÅ mono‚ÇÅ, hinduction s‚ÇÇ with a‚ÇÇ h‚ÇÇ mono‚ÇÇ,
  change a‚ÇÅ = a‚ÇÇ at p, hinduction p, 
  change ap subobject.obj (apd0111 subobject.mk idp q _) = idp, 
  let HP : Œ† (a : C) (h : a ‚ü∂ c) (m : is_mono h), 
              subobject.obj (subobject.mk a h m) = a := assume a h m, rfl,
  rwr ap_apd0111 subobject.mk idp q _ subobject.obj HP
end

/- A homomorphism between subobjects compatible with the injections is itself an injection. Hence,
   homomorphisms between subobjects in both ways imply an isomorphism of subobjects and therefore
   equality. -/
@[hott]
def subobject_hom {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :=
  hom_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono

@[hott, instance]
def subobject_hom_is_prop {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :
  is_prop (subobject_hom s‚ÇÅ s‚ÇÇ) :=
begin change is_prop (hom_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono), apply_instance end    

@[hott]
def equal_subobj_to_iso_mono {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :
  s‚ÇÅ = s‚ÇÇ -> iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono :=
begin 
  intro p, fapply iso_of_monos.mk, 
  exact (idtoiso (ap subobject.obj p)), 
  hinduction p, hsimp 
end  

@[hott] 
def idp_subobj_to_iso_mono {C : Category} {c : C} (s : subobject c) :
  equal_subobj_to_iso_mono s s idp = iso_of_monos.mk s.is_mono s.is_mono (id_iso s.obj) 
                                                     (is_precat.id_comp s.hom) :=
begin apply iso_of_monos_eq, change idtoiso idp = id_iso s.obj, rwr idtoiso_refl_eq end                                                     

@[hott, reducible]
def iso_mono_to_equal_subobj {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :
  iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono -> s‚ÇÅ = s‚ÇÇ :=
begin
  intro im, fapply subobject_eq,
  { exact idtoiso‚Åª¬π·∂† im.iso_obj },
  { apply pathover_of_tr_eq, rwr iso_hom_tr_comp, 
    apply eq.inverse, apply iso_move_lr, rwr im.fac }
end

@[hott]
def iso_mono_to_equal_subobj_iso {C : Category} {c : C} {s‚ÇÅ s‚ÇÇ : subobject c} 
  (im : iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono) : 
  ap subobject.obj (iso_mono_to_equal_subobj s‚ÇÅ s‚ÇÇ im) = category.isotoid im.iso_obj :=
begin
  hinduction s‚ÇÅ with obj‚ÇÅ hom‚ÇÅ is_mono‚ÇÅ, hinduction s‚ÇÇ with obj‚ÇÇ hom‚ÇÇ is_mono‚ÇÇ,
  change ap subobject.obj (subobject_eq _ _) = _, rwr subobject_eq_obj   
end    

@[hott]
def equal_subobj_eqv_iso_mono {C : Category} {c : C} (s‚ÇÅ s‚ÇÇ : subobject c) :
  s‚ÇÅ = s‚ÇÇ ‚âÉ iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono :=
begin
  fapply equiv.mk,
  { exact equal_subobj_to_iso_mono s‚ÇÅ s‚ÇÇ },
  { fapply adjointify,
    { exact iso_mono_to_equal_subobj s‚ÇÅ s‚ÇÇ },
    { hinduction s‚ÇÅ with obj‚ÇÅ hom‚ÇÅ is_mono‚ÇÅ, hinduction s‚ÇÇ with obj‚ÇÇ hom‚ÇÇ is_mono‚ÇÇ,
      intro im, hinduction im with iso_obj fac, apply iso_of_monos_eq _ _, hsimp,
      change idtoiso (ap subobject.obj _) = _, rwr iso_mono_to_equal_subobj_iso,
      rwr category.idtoiso_rinv' },
    { intro p, hinduction p, rwr idp_subobj_to_iso_mono,
      change subobject_eq (category.isotoid (id_iso s‚ÇÅ.obj)) _ = _,
      rwr fn2_ev_fn2_tr' _ _ subobject_eq, rwr subobject_eq_idp, 
      exact isotoid_id_refl s‚ÇÅ.obj } }
end


/- The subobjects of an object in a HoTT-category form a set, so a HoTT-category is 
   well-powered. -/
@[hott, instance]
def subobject_is_set {C : Category} (c : C) : is_set (subobject c) :=
begin 
  apply is_trunc_succ_intro, intros s‚ÇÅ s‚ÇÇ, 
  apply is_trunc_equiv_closed_rev -1 (equal_subobj_eqv_iso_mono s‚ÇÅ s‚ÇÇ), 
  apply is_trunc_equiv_closed -1 (homs_eqv_iso_of_monos s‚ÇÅ.is_mono s‚ÇÇ.is_mono), 
  apply_instance 
end

@[hott]
def Subobject {C : Category} (c : C) : Set :=
  Set.mk (subobject c) (subobject_is_set c)

/- The subobjects of an object, together with their monomorphism-preserving homomorphisms
   defined in [categories.basic], form a category. -/  
@[hott, instance]
def subobject_has_hom {C : Category} {c : C} : has_hom (subobject c) :=
  has_hom.mk (Œª a b : subobject c, Set.mk (subobject_hom a b) (is_trunc_succ _ -1))

@[hott]
def id_subobject {C : Category} {c : C} (a : subobject c) : subobject_hom a a :=
  begin fapply hom_of_monos.mk a.is_mono a.is_mono, exact ùüô a.obj, hsimp end  

@[hott] 
def comp_subobject {C : Category} {c : C} (a‚ÇÅ a‚ÇÇ a‚ÇÉ : subobject c) :
  subobject_hom a‚ÇÅ a‚ÇÇ -> subobject_hom a‚ÇÇ a‚ÇÉ -> subobject_hom a‚ÇÅ a‚ÇÉ :=
begin 
  intros f g, fapply hom_of_monos.mk a‚ÇÅ.is_mono a‚ÇÉ.is_mono, exact f.hom_obj ‚â´ g.hom_obj, 
  rwr is_precat.assoc, rwr g.fac, rwr f.fac 
end  

@[hott, instance]
def subobject_cat_struct {C : Category} {c : C} : 
  category_struct (subobject c) :=
category_struct.mk id_subobject comp_subobject

@[hott, instance]
def subobject_is_precat {C : Category} {c : C} : 
  is_precat (subobject c) :=
have ic : Œ† (a b : subobject c) (f : a ‚ü∂ b), ùüô a ‚â´ f = f, from 
  assume a b f, by exact is_prop.elim _ _,
have ci : Œ† (a b : subobject c) (f : a ‚ü∂ b), f ‚â´ ùüô b = f, from 
  assume a b f, by exact is_prop.elim _ _,
have as : Œ† (a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÑ : subobject c) (f : a‚ÇÅ ‚ü∂ a‚ÇÇ) (g : a‚ÇÇ ‚ü∂ a‚ÇÉ) (h : a‚ÇÉ ‚ü∂ a‚ÇÑ),
             (f ‚â´ g) ‚â´ h = f ‚â´ (g ‚â´ h), from 
  assume a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÑ f g h, by exact is_prop.elim _ _,
is_precat.mk ic ci as  

@[hott]
def iso_of_monos_to_iso {C : Category} {c : C} (a b : subobject c) :
  (iso_of_monos a.is_mono b.is_mono) -> (a ‚âÖ b) :=
begin 
  intro im, fapply iso.mk, 
  { fapply hom_of_monos.mk, exact im.iso_obj.hom, exact im.fac }, 
  { fapply is_iso.mk,
    fapply hom_of_monos.mk, exact im.iso_obj.ih.inv, apply eq.inverse, apply iso_move_lr, 
    exact im.fac, exact is_prop.elim _ _, exact is_prop.elim _ _ } 
end

@[hott]
def iso_to_iso_of_monos {C : Category} {c : C} (a b : subobject c) :
  (a ‚âÖ b) -> (iso_of_monos a.is_mono b.is_mono) :=
begin 
  intro i, fapply iso_of_monos.mk, 
  { fapply iso.mk, exact i.hom.hom_obj, fapply is_iso.mk, 
    exact i.ih.inv.hom_obj, 
    exact ap hom_of_monos.hom_obj i.ih.r_inv, 
    exact ap hom_of_monos.hom_obj i.ih.l_inv },
  { exact i.hom.fac }
end    

@[hott]
def iso_of_monos_eqv_iso {C : Category} {c : C} (a b : subobject c) :
  (iso_of_monos a.is_mono b.is_mono) ‚âÉ (a ‚âÖ b) :=
begin 
  fapply equiv.mk,
  { exact iso_of_monos_to_iso a b },
  { fapply adjointify, 
    { exact iso_to_iso_of_monos a b },
    { intro i, apply hom_eq_to_iso_eq, exact is_prop.elim _ _ },
    { intro i, exact @is_prop.elim _ 
              (is_prop_iso_of_monos a.is_mono b.is_mono) _ _ } }
end  

@[hott]
def subobj_idtoiso {C : Category} {c : C} (a b : subobject c) : 
  @idtoiso _ _ a b = (iso_of_monos_eqv_iso a b).to_fun ‚àò 
                     (equal_subobj_eqv_iso_mono a b).to_fun :=
begin apply eq_of_homotopy, intro p, apply hom_eq_to_iso_eq, exact is_prop.elim _ _ end                       

@[hott, instance]
def subobject_is_cat {C : Category} {c : C} : 
  is_cat (subobject c) :=
begin apply is_cat.mk, intros a b, rwr subobj_idtoiso a b, apply_instance end    

@[hott]
def subobject_Category {C : Category} (c : C) : Category :=
  Category.mk (subobject c) subobject_is_cat

/- Since homomorphisms between subobjects are unique and anti-symmetric (see below), 
   they can be seen as an order on the set of subobjects. To emphasize this point of 
   view, we introduce a `‚â§`-notation for these homomorphisms. 
   
   A `has_le`-class is introduced in [algebra.order], but there seems to be universe
   problems when used with subobjects in categories. -/
@[hott]
class has_order (A : Type _) := (le : A ‚Üí A ‚Üí Type _)

hott_theory_cmd "local infix ` ‚âº `:60  := hott.has_order.le"

@[hott, instance]
def subobject_has_order {C : Category.{u v}} (c : C) : 
  has_order.{(max u v) v} (subobject c) :=
  has_order.mk (Œª a b, a ‚ü∂ b)  

@[hott]
def subobj_antisymm {C : Category} {c : C} (a b : subobject c) : 
  (a ‚âº b) -> (b ‚âº a) -> (a = b) :=
begin 
  intros i j , 
  have iso_ab : a ‚âÖ b, from 
    begin 
      fapply iso.mk, exact i, fapply is_iso.mk, exact j, 
      exact @is_prop.elim _ (subobject_hom_is_prop b b) _ _, 
      exact @is_prop.elim _ (subobject_hom_is_prop a a) _ _ 
    end,  
  exact @category.isotoid (subobject_Category c) _ _ iso_ab 
end  

@[hott]
def subobj_trans {C : Category} {d : C} {a b c : subobject d} : 
  (a ‚âº b) -> (b ‚âº c) -> (a ‚âº c) :=
Œª i j, i ‚â´ j 

@[hott]
def subobj_subobj_trans {C : Category} {c : C} (a : subobject c) 
  (b : subobject a.obj) : subobject c :=
subobject.mk b.obj (b.hom ‚â´ a.hom) (is_mono_is_trans b.is_mono a.is_mono) 

@[hott]
def subobj_trans_hom_hom {C : Category} {c : C} (a : subobject c) 
  (b : subobject a.obj) : (subobj_subobj_trans a b).hom = b.hom ‚â´ a.hom := rfl

@[hott]
def subobj_subobj_trans_hom {C : Category} {c : C} (a : subobject c) 
  (b : subobject a.obj) : subobj_subobj_trans a b ‚âº a :=
begin fapply hom_of_monos.mk, exact b.hom, refl end

@[hott]
def subobj_subobj_trans_pres_hom {C : Category} {d : C} (a : subobject d) 
  (b c : subobject a.obj) : b ‚âº c -> subobj_subobj_trans a b ‚âº subobj_subobj_trans a c :=
begin
  intro bc, fapply hom_of_monos.mk, 
  { exact bc.hom_obj },
  { change _ ‚â´ c.hom ‚â´ a.hom = b.hom ‚â´ a.hom, rwr <- is_precat.assoc, rwr bc.fac }
end

@[hott]
def subobj_rest {C : Category} {c : C} {a b : subobject c} (f : b ‚âº a) :
  subobject a.obj := 
subobject.mk b.obj f.hom_obj (hom_of_monos_is_mono f)

@[hott]
def subobj_hom_rest {C : Category} {c : C} {a b b': subobject c} (f : b ‚âº a) 
  (f' : b' ‚âº a) (g : b ‚âº b') : (subobj_rest f) ‚ü∂ (subobj_rest f') :=
begin 
  fapply hom_of_monos.mk, exact g.hom_obj, change (g ‚â´ f').hom_obj = f.hom_obj,
  apply ap hom_of_monos.hom_obj, exact is_prop.elim _ _
end

@[hott]
def subobj_hom_rest_hom {C : Category} {c : C} {a b b': subobject c} (f : b ‚âº a) 
  (f' : b' ‚âº a) (g : subobj_rest f ‚âº subobj_rest f') : b ‚âº b' :=
begin 
  fapply hom_of_monos.mk, exact g.hom_obj, 
  rwr <- f'.fac, rwr <- f.fac, rwr <- is_precat.assoc,
  apply ap (Œª h : b.obj ‚ü∂ a.obj, h ‚â´ a.hom), 
  change _ ‚â´ (subobj_rest f').hom = _, rwr g.fac
end  

@[hott]
def subobj_rest_trans {C : Category} {c : C} (a : subobject c) (b : subobject a.obj) :
  subobj_rest (subobj_subobj_trans_hom a b) = b :=
begin 
  fapply subobj_antisymm,
  { fapply hom_of_monos.mk, 
    { exact ùüô b.obj },
    { rwr is_precat.id_comp b.hom } },
  { fapply hom_of_monos.mk,
    { exact ùüô b.obj },
    { rwr is_precat.id_comp } } 
end

/- The category of subobjects always has a top element. -/
@[hott]
def top_subobject {C : Category} (c : C) : subobject c := 
  subobject.mk c (ùüô c) (isos_are_mono (id_iso c))

@[hott]
def top_subobj_prop {C : Category} {c : C} : 
  Œ† (a : subobject c), a ‚âº top_subobject c := 
begin intro a, fapply hom_of_monos.mk, exact a.hom, hsimp end 

@[hott]
def top_subobj_unique {C : Category} {c : C} (d : subobject c) :
  (Œ† (a : subobject c), a ‚âº d) -> d = top_subobject c :=
begin intro max, fapply subobj_antisymm, exact top_subobj_prop d, exact max _ end
 

/- We can define images of homomorphisms as subobjects of their codomain satisfying a 
   minimality property. Note that the factoring homomorphism is unique as the inclusion 
   homomorphism is a monomorphism. -/
@[hott]
structure cat_image {C : Category} {c d : C} (f : c ‚ü∂ d) :=
  (subobj : subobject d)
  (fac : Œ£ f' : c ‚ü∂ subobj.obj, f' ‚â´ subobj.hom = f)
  (univ : Œ† (a : subobject d), (Œ£ f' : c ‚ü∂ a.obj, f' ‚â´ a.hom = f) -> (subobj ‚âº a))

@[hott] 
def subobject_fac_is_unique {C : Category.{u v}} {c d : C} (f : c ‚ü∂ d) 
  (a : subobject d) : Œ† fac‚ÇÅ fac‚ÇÇ : (Œ£ (f' : c ‚ü∂ a.obj), f' ‚â´ a.hom = f), fac‚ÇÅ = fac‚ÇÇ :=
begin 
  intros fac‚ÇÅ fac‚ÇÇ, fapply sigma.sigma_eq, 
  { fapply a.is_mono, exact fac‚ÇÅ.2 ‚¨ù fac‚ÇÇ.2‚Åª¬π }, 
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ } 
end

@[hott, instance] 
def subobject_fac_is_prop {C : Category.{u v}} {c d : C} (f : c ‚ü∂ d) 
  (a : subobject d) : is_prop (Œ£ f' : c ‚ü∂ a.obj, f' ‚â´ a.hom = f) :=
is_prop.mk (subobject_fac_is_unique f a)  

@[hott]
def cat_image_is_unique {C : Category.{u v}} {c d : C} (f : c ‚ü∂ d) :
  Œ† im‚ÇÅ im‚ÇÇ : cat_image f, im‚ÇÅ = im‚ÇÇ :=
begin
  intros im‚ÇÅ im‚ÇÇ, 
  hinduction im‚ÇÅ with subobj‚ÇÅ fac‚ÇÅ univ‚ÇÅ, hinduction im‚ÇÇ with subobj‚ÇÇ fac‚ÇÇ univ‚ÇÇ, 
  fapply apdd2 cat_image.mk, 
  { fapply subobj_antisymm, exact univ‚ÇÅ subobj‚ÇÇ fac‚ÇÇ, exact univ‚ÇÇ subobj‚ÇÅ fac‚ÇÅ },
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ },
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ }
end  

@[hott, instance]
def cat_image_is_prop {C : Category} {c d : C} (f : c ‚ü∂ d) : 
  is_prop (cat_image f) :=
is_prop.mk (cat_image_is_unique f)  

@[hott]
class has_image {C : Category} {c d : C} (f : c ‚ü∂ d) :=
  (exists_im : cat_image f)

@[hott, instance]
def has_im_is_prop {C : Category} {c d : C} (f : c ‚ü∂ d) : is_prop (has_image f) :=
begin 
  apply is_prop.mk, intros hi‚ÇÅ hi‚ÇÇ, hinduction hi‚ÇÅ, hinduction hi‚ÇÇ,
  apply ap has_image.mk, exact is_prop.elim _ _ 
end

@[hott, reducible]
def hom.image {C : Category} {c d : C} (f : c ‚ü∂ d) [has_image f] : 
  subobject d :=  
(has_image.exists_im f).subobj

@[hott, reducible]
def hom_to_image {C : Category} {c d : C} (f : c ‚ü∂ d) [has_image f] :
  c ‚ü∂ (hom.image f).obj := 
(has_image.exists_im f).fac.1  

@[hott]
def hom_to_image_eq {C : Category} {c d : C} (f : c ‚ü∂ d) [has_image f] :
  hom_to_image f ‚â´ (hom.image f).hom = f := 
(has_image.exists_im f).fac.2 

@[hott]
def hom_image_univ {C : Category} {c d : C} (f : c ‚ü∂ d) [has_image f] :
  Œ† (a : subobject d) (f' : c ‚ü∂ a.obj), f' ‚â´ a.hom = f -> (hom.image f ‚âº a) :=
assume a f' p, (has_image.exists_im f).univ a ‚ü®f', p‚ü© 

@[hott, instance]
def subobj_has_im {C : Category} {c : C} (b : subobject c) :
  has_image b.hom :=
have im_b : cat_image b.hom, from 
  cat_image.mk b (sigma.mk (ùüô b.obj) (is_precat.id_comp b.hom)) 
               (Œª a m, hom_of_monos.mk _ _ m.1 m.2),  
has_image.mk im_b

@[hott]
def subobj_is_im {C : Category} {c : C} (b : subobject c) :
  hom.image b.hom = b := idp  

@[hott]
def im_incl {C : Category} {a b c : C} (f : a ‚ü∂ b) (g : b ‚ü∂ c) 
  [has_image (f ‚â´ g)] [has_image g] : hom.image (f ‚â´ g) ‚âº hom.image g :=
begin 
  fapply cat_image.univ, fapply sigma.mk, 
  { exact f ‚â´ hom_to_image g }, 
  { rwr is_precat.assoc, rwr hom_to_image_eq g }
end  

@[hott]
def im_incl_eq {C : Category} 
  {c d : C} (a : subobject c) (f : d ‚ü∂ a.obj) [has_image f] [has_image (f ‚â´ a.hom)] : 
  (hom.image (f ‚â´ a.hom)) = (subobj_subobj_trans a (hom.image f)) :=
begin 
  have p : hom_to_image f ‚â´ (subobj_subobj_trans a (hom.image f)).hom = f ‚â´ a.hom, from
    begin change _ ‚â´ _ ‚â´ _ = _, rwr <- is_precat.assoc, rwr hom_to_image_eq end,
  let g := hom_image_univ (f ‚â´ a.hom) (subobj_subobj_trans a (hom.image f)) 
                                                                   (hom_to_image f) p,
  fapply subobj_antisymm, 
  { exact g }, 
  { fapply @subobj_hom_rest_hom _ _ a, 
    { exact subobj_subobj_trans_hom _ _ },
    { exact g ‚â´ subobj_subobj_trans_hom _ _ },
    { rwr subobj_rest_trans, fapply hom_image_univ, 
      { exact hom_to_image (f ‚â´ a.hom) },
      { fapply a.is_mono, apply Œª p, p ‚¨ù hom_to_image_eq (f ‚â´ a.hom), 
        rwr is_precat.assoc, 
        change _ ‚â´ (g ‚â´ subobj_subobj_trans_hom a (hom.image f)).hom_obj ‚â´ _ = _,
        rwr (g ‚â´ subobj_subobj_trans_hom a (hom.image f)).fac } } }
end

@[hott]
def im_iso_comp {C : Category} {a b c : C} (i : a ‚âÖ b) (g : b ‚ü∂ c) 
  [has_image (i.hom ‚â´ g)] [has_image g] : hom.image (i.hom ‚â´ g) = hom.image g :=
begin
  apply subobj_antisymm,
  { fapply hom_image_univ,
    { exact i.hom ‚â´ hom_to_image g },
    { rwr is_precat.assoc, rwr hom_to_image_eq } },
  { fapply hom_image_univ, 
    { exact i.ih.inv ‚â´ hom_to_image (i.hom ‚â´ g) },
    { rwr is_precat.assoc, rwr hom_to_image_eq, rwr <- is_precat.assoc, 
      rwr i.ih.r_inv, rwr is_precat.id_comp } }
end

@[hott]
class has_images (C : Category) :=
  (has_im : Œ† {c d : C} (f : c ‚ü∂ d), has_image f)

@[hott, instance]
def has_ims_is_prop (C : Category) : is_prop (has_images C) :=
begin 
  apply is_prop.mk, intros hi‚ÇÅ hi‚ÇÇ, hinduction hi‚ÇÅ, hinduction hi‚ÇÇ,
  apply ap has_images.mk, exact is_prop.elim _ _ 
end

@[hott, instance]
def has_image_of_has_images {C : Category} [has_images C] {c d : C} 
  (f : c ‚ü∂ d) : has_image f :=
has_images.has_im f

end hott