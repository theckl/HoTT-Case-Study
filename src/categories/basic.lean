import setalgebra pathover2 set_axioms

universes v u v' u' w 
hott_theory

namespace hott
open hott.eq hott.set hott.subset hott.is_trunc hott.is_equiv

/-
We introduce precategories and categories following the HoTT book, 
Sec. 9.1. HoTT precategories have sets of homomorphisms, and HoTT categories 
prescribe univalence : Isomorphisms are equivalent to identities of objects.

As far as possible we copy the mathlib-code in [category_theory.category.default].
-/

namespace categories

/-- A 'notation typeclass' on the way to defining a precategory. -/
@[hott]
class has_hom (obj : Type u) : Type (max u (v+1)):=
  (hom : obj â†’ obj â†’ Set.{v})

infixr ` âŸ¶ `:10 := has_hom.hom  -- type as \h

/-- A preliminary structure on the way to defining a precategory,
containing the data, but none of the axioms. -/
@[hott]
class category_struct (obj : Type u) 
extends has_hom.{v} obj : Type (max u (v+1)) :=
(id       : Î  a : obj, hom a a)
(comp     : Î  {a b c : obj}, (a âŸ¶ b) â†’ (b âŸ¶ c) â†’ (a âŸ¶ c))

notation `ğŸ™` := category_struct.id -- type as \b1
infixr ` â‰« `:80 := category_struct.comp -- type as \gg

/-- The structure of a precategory. -/
@[hott, class]
structure precategory (obj : Type u) 
extends category_struct.{v} obj : Type (max u (v+1)) :=
(id_comp : âˆ€ {a b : obj} (f : hom a b), ğŸ™ a â‰« f = f)
(comp_id : âˆ€ {a b : obj} (f : hom a b), f â‰« ğŸ™ b = f)
(assoc   : âˆ€ {a b c d : obj} (f : hom a b) (g : hom b c) (h : hom c d),
  (f â‰« g) â‰« h = f â‰« (g â‰« h))

attribute [hsimp] precategory.id_comp precategory.comp_id precategory.assoc

/- Defintion of categorical isomorphisms. -/
@[hott]
structure iso {C : Type u} [precategory.{v} C] (a b : C) :=
  (hom : a âŸ¶ b)
  (inv : b âŸ¶ a) 
  (r_inv : inv â‰« hom = ğŸ™ b) 
  (l_inv : hom â‰« inv = ğŸ™ a) 

postfix `â»Â¹Ê°`:std.prec.max_plus := iso.inv

infix ` â‰… `:25 := iso
 
@[hott]
def iso.eta {C : Type u} [precategory.{v} C] {a b : C} (i : a â‰… b) : 
  i = iso.mk i.hom i.inv i.r_inv i.l_inv :=
begin hinduction i, hsimp end  

@[hott, hsimp]
def inv_iso {C : Type u} [precategory.{v} C] {a b : C} (i : a â‰… b) : b â‰… a :=
  iso.mk i.inv i.hom i.l_inv i.r_inv

/- Calculation rules for isomorphisms. -/
@[hott, hsimp]
def iso_inv_inv {C : Type u} [precategory.{v} C] {a b : C} (i : a â‰… b) :
  (inv_iso i)â»Â¹Ê° = i.hom :=
by hsimp 

@[hott, hsimp]
def iso_rcancel {C : Type u} [precategory.{v} C] {a b c : C} (i : a â‰… b)
  {g h : c âŸ¶ a} : g â‰« i.hom = h â‰« i.hom -> g = h :=
assume pc, 
have pc_inv : (g â‰« i.hom) â‰« i.inv = (h â‰« i.hom) â‰« i.inv, from 
  ap (Î» h : c âŸ¶ b, h â‰« i.inv) pc,
calc   g = g â‰« ğŸ™ a : by hsimp
     ... = g â‰« (i.hom â‰« i.inv) : by rwr <-i.l_inv
     ... = (g â‰« i.hom) â‰« i.inv : by hsimp
     ... = (h â‰« i.hom) â‰« i.inv : by rwr pc_inv
     ... = h â‰« (i.hom â‰« i.inv) : by hsimp
     ... = h â‰« ğŸ™ a : by rwr i.l_inv     
     ... = h : by hsimp 

@[hott, hsimp]
def iso_lcancel {C : Type u} [precategory.{v} C] {a b c : C} (i : a â‰… b)
  {g h : b âŸ¶ c} : i.hom â‰« g = i.hom â‰« h -> g = h :=
assume cp, 
have cp_inv : i.inv â‰« (i.hom â‰« g) = i.inv â‰« (i.hom â‰« h), from 
  ap (Î» h : a âŸ¶ c, i.inv â‰« h) cp,
calc   g = ğŸ™ b â‰« g : by hsimp
     ... = (i.inv â‰« i.hom) â‰« g : by rwr <-i.r_inv
     ... = i.inv â‰« (i.hom â‰« g) : by hsimp
     ... = i.inv â‰« (i.hom â‰« h) : by rwr cp_inv
     ... = (i.inv â‰« i.hom) â‰« h : by hsimp
     ... = ğŸ™ b â‰« h : by rwr i.r_inv     
     ... = h : by hsimp 

@[hott, hsimp]
def iso_move_lr {C : Type u} [precategory.{v} C] {a b c : C} (i : a â‰… b)
  (g : b âŸ¶ c) (h : a âŸ¶ c) : i.hom â‰« g = h -> g = i.inv â‰« h :=
assume pcr,
have i.inv â‰« i.hom â‰« g = i.inv â‰« h, from ap (Î» h : a âŸ¶ c, i.inv â‰« h) pcr,
calc g   = ğŸ™ b â‰« g : by hsimp
     ... = (i.inv â‰« i.hom) â‰« g : by rwr <-i.r_inv
     ... = i.inv â‰« (i.hom â‰« g) : by hsimp
     ... = i.inv â‰« h : by rwr pcr   

@[hott, hsimp]
def iso_move_rl {C : Type u} [precategory.{v} C] {a b c : C} (i : a â‰… b)
  (g : c âŸ¶ a) (h : c âŸ¶ b) : g â‰« i.hom = h  -> g = h â‰« i.inv :=
assume pcl,
have (g â‰« i.hom) â‰« i.inv = h â‰« i.inv, from ap (Î» h : c âŸ¶ b, h â‰« i.inv) pcl,
calc g   = g â‰« ğŸ™ a : by hsimp
     ... = g â‰« (i.hom â‰« i.inv) : by rwr <-i.l_inv
     ... = (g â‰« i.hom) â‰« i.inv : by hsimp
     ... = h â‰« i.inv : by rwr pcl 

/- Isomorphisms are uniquely determined by their underlying homomorphism:
   The inverse map by functorial equalities, and the functorial equalities 
   because the types of homomorphisms are sets. -/
@[hott]
def hom_eq_to_iso_eq {C : Type u} [precategory.{v} C] {a b : C} {i j : a â‰… b} :
  i.hom = j.hom -> i = j :=
assume hom_eq, 
have inv_eq : i.inv = j.inv, from 
  calc i.inv = i.inv â‰« ğŸ™ a : by hsimp
       ...   = i.inv â‰« (j.hom â‰« j.inv) : by rwr j.l_invâ»Â¹ 
       ...   = (i.inv â‰« j.hom) â‰« j.inv : by hsimp
       ...   = (i.inv â‰« i.hom) â‰« j.inv : by rwr hom_eqâ»Â¹
       ...   = ğŸ™ b â‰« j.inv : by rwr i.r_inv
       ...   = j.inv : by hsimp,
let R := Î» (f : a âŸ¶ b) (g : b âŸ¶ a), g â‰« f = ğŸ™ b,
    L := Î» (f : a âŸ¶ b) (g : b âŸ¶ a), f â‰« g = ğŸ™ a in
have r_inv_eq : i.r_inv =[ap011 R hom_eq inv_eq; set.id] j.r_inv, from 
  begin apply pathover_of_tr_eq, apply is_set.elim end,
have l_inv_eq : i.l_inv =[ap011 L hom_eq inv_eq; set.id] j.l_inv, from 
  begin apply pathover_of_tr_eq, apply is_set.elim end, 
calc   i = iso.mk i.hom i.inv i.r_inv i.l_inv : iso.eta i 
     ... = iso.mk j.hom j.inv j.r_inv j.l_inv : 
                                        ap0111 iso.mk hom_eq inv_eq r_inv_eq l_inv_eq
     ... = j : (iso.eta j)â»Â¹

@[hott, hsimp]
def id_is_iso {C : Type u} [precategory.{v} C] (a : C) : a â‰… a := 
  have inv_eq : ğŸ™ a â‰« ğŸ™ a = ğŸ™ a, from precategory.id_comp (ğŸ™ a),
  iso.mk (ğŸ™ a) (ğŸ™ a) inv_eq inv_eq

@[hott, hsimp]
def idtoiso {C : Type u} [precategory.{v} C] {a b : C} : (a = b) -> (a â‰… b) :=
  begin intro eq, hinduction eq, exact id_is_iso a end

/- `idtoiso` is natural. -/
@[hott, hsimp]
def idtoiso_refl_eq {C : Type u} [precategory.{v} C] (a : C) : idtoiso (refl a) = id_is_iso a :=
  by hsimp

@[hott]
def id_inv_iso_inv {C : Type u} [precategory.{v} C] {câ‚ câ‚‚ : C} (p : câ‚ = câ‚‚) :
  idtoiso pâ»Â¹ = inv_iso (idtoiso p) := 
begin hinduction p, refl end 

@[hott]
def id_hom_tr_comp {C : Type u} [precategory.{v} C] {câ‚ câ‚‚ d : C} (p : câ‚ = câ‚‚)
  (h : câ‚ âŸ¶ d) : p â–¸ h = (idtoiso p)â»Â¹Ê° â‰« h :=
begin hinduction p, hsimp end   


/-- The structure of a category. -/
@[hott]
class category (obj : Type u) extends precategory.{v} obj :=
(ideqviso : âˆ€ a b : obj, is_equiv (@idtoiso _ _ a b)) 

attribute [instance] category.ideqviso

@[hott]
def category.isotoid {obj : Type u} [category.{v} obj] : 
  Î  {a b : obj}, a â‰… b -> a = b :=
assume a b iso,  
@is_equiv.inv _ _ _ (category.ideqviso a b) iso  

@[hott]
def category.idtoiso_rinv {obj : Type u} [category.{v} obj] {a b : obj} :
  âˆ€ i : a â‰… b, idtoiso (idtoisoâ»Â¹á¶  i) = i :=
is_equiv.right_inv (@idtoiso _ _ a b) 

@[hott]
def category.idtoiso_linv {obj : Type u} [category.{v} obj] {a b : obj} :
  âˆ€ p : a = b, idtoisoâ»Â¹á¶  (idtoiso p) = p :=
is_equiv.left_inv (@idtoiso _ _ a b) 

@[hott]
def iso_hom_tr_comp {C : Type u} [category.{v} C] {câ‚ câ‚‚ d : C} (i : câ‚ â‰… câ‚‚)
  (h : câ‚ âŸ¶ d) : (idtoisoâ»Â¹á¶  i) â–¸ h = iâ»Â¹Ê° â‰« h :=
begin 
  rwr <-(category.idtoiso_rinv i),  
  rwr category.idtoiso_linv (idtoisoâ»Â¹á¶  i),
  exact id_hom_tr_comp (idtoisoâ»Â¹á¶  i) h
end 

section
variables (C : Type u) (D : Type u')

/- Functors are defined between precategories. -/
@[hott]
structure functor [precategory.{v} C] [precategory.{v'} D] :
  Type (max v v' u u') :=
(obj      : C â†’ D)
(map      : Î  {x y : C}, (x âŸ¶ y) â†’ ((obj x) âŸ¶ (obj y)))
(map_id   : âˆ€ (x : C), map (ğŸ™ x) = ğŸ™ (obj x))
(map_comp : âˆ€ {x y z : C} (f : x âŸ¶ y) (g : y âŸ¶ z), map (f â‰« g) = (map f) â‰« (map g))

infixr ` â¥¤ `:26 := functor       

attribute [hsimp] functor.map_id
attribute [hsimp] functor.map_comp

@[hott]
def constant_functor [precategory.{v} C] [precategory.{v'} D] (d : D) : 
  C â¥¤ D := 
have id_hom_eq : âˆ€ d : D, ğŸ™ d = ğŸ™ d â‰« ğŸ™ d, by intro d; hsimp,  
functor.mk (Î» c : C, d) (Î» câ‚ câ‚‚ f, ğŸ™ d) (Î» c, rfl) 
  (Î» câ‚ câ‚‚ câ‚ƒ f g, (id_hom_eq d))

@[hott]
structure nat_trans [precategory.{v} C] [precategory.{v'} D] (F G : C â¥¤ D) :=
(app : Î  c : C, (F.obj c) âŸ¶ (G.obj c))
(naturality : âˆ€ {c c' : C} (f : c âŸ¶ c'), 
                                 (F.map f) â‰« (app c') = (app c) â‰« (G.map f))  

infixr ` âŸ¹ `:10 := nat_trans _ _

/- We now define structures on categories and prove the Structure Identity Principle, following
   the [HoTT-Book], Section 9.8. -/
@[hott]
structure std_structure_on (C : Type u) [category.{v} C] :=
  (P : C -> Type u)
  (H : Î  {x y : C} (Î± : P x) (Î² : P y) (f : x âŸ¶ y), trunctype.{u} -1)
  (id_H : âˆ€ {x : C} (Î± : P x), H Î± Î± (ğŸ™ x))
  (comp_H : âˆ€ {x y z : C} (Î± : P x) (Î² : P y) (Î³ : P z) (f : x âŸ¶ y) (g : y âŸ¶ z), 
              H Î± Î² f -> H Î² Î³ g -> H Î± Î³ (f â‰« g))
  (std : âˆ€ {x y : C} (Î± Î² : P x) , H Î± Î² (ğŸ™ x) -> H Î² Î± (ğŸ™ x) -> Î± = Î²)           

@[hott]
structure std_structure {C : Type u} [category.{v} C] (std_str : std_structure_on C) :=
  (carrier : C)
  (str : std_str.P carrier)

@[hott]
instance {C : Type u} [category.{v} C] (std_str : std_structure_on C) : 
  has_coe (std_structure std_str) C :=
âŸ¨Î» x : std_structure std_str, x.carrierâŸ©  

@[hott, instance]
def std_str_has_hom {C : Type u} [category.{u} C] (std_str : std_structure_on C) :
  has_hom (std_structure std_str) := 
has_hom.mk (Î» (x y : std_structure std_str), 
            â†¥{ f âˆˆ (x.carrier âŸ¶ y) | std_str.H (x.str) (y.str) f })

@[hott]
instance hom_std_C {C : Type u} [category.{u} C] {std_str : std_structure_on C}
  {x y : std_structure std_str} : has_coe â†¥(x âŸ¶ y) â†¥(x.carrier âŸ¶ y.carrier) :=
âŸ¨Î» f, { f âˆˆ (x.carrier âŸ¶ y) | std_str.H (x.str) (y.str) f }.map fâŸ©  

@[hott]
def hom_H {C : Type u} [category.{u} C] {std_str : std_structure_on C} 
  {x y : std_structure std_str} :
  Î  f : x âŸ¶ y, std_str.H x.str y.str (â†‘f) :=
assume f, f.2              

@[hott]
def hom_eq_C_std {C : Type u} [category.{u} C] {std_str : std_structure_on C} 
  {x y : std_structure std_str} (f g : x âŸ¶ y) : 
  (â†‘f = (â†‘g : x.carrier âŸ¶ y.carrier)) -> (f = g) :=
sorry  

@[hott, instance]
def std_str_cat_struct {C : Type u} [category.{u} C] (std_str : std_structure_on C) :
  category_struct (std_structure std_str) :=
category_struct.mk (Î» x : std_structure std_str, elem_pred (ğŸ™ â†‘x) (std_str.id_H x.str)) 
  (Î» (x y z : std_structure std_str) (f : x âŸ¶ y) (g : y âŸ¶ z), 
   elem_pred (â†‘f â‰« â†‘g) (std_str.comp_H x.str y.str z.str â†‘f â†‘g (hom_H f) (hom_H g))) 

@[hott]
def idhom_std_C {C : Type u} [category.{u} C] {std_str : std_structure_on C} 
  (x : std_structure std_str) : â†‘(ğŸ™ x) = ğŸ™ x.carrier :=
sorry  

@[hott]
def comp_hom_std_C {C : Type u} [category.{u} C] {std_str : std_structure_on C} 
  {x y z : std_structure std_str} (f : x âŸ¶ y) (g : y âŸ¶ z) : 
  â†‘(f â‰« g) = (â†‘f : x.carrier âŸ¶ y.carrier) â‰« (â†‘g : y.carrier âŸ¶ z.carrier) :=
sorry  

@[hott, instance]
def std_str_precategory {C : Type u} [category.{u} C] (std_str : std_structure_on C) :
  precategory (std_structure std_str) :=
have ic : âˆ€ (x y : std_structure std_str) (f : x âŸ¶ y), ğŸ™ x â‰« f = f, from 
  begin intros x y f, apply hom_eq_C_std _ _, rwr comp_hom_std_C, hsimp end,
have ci : âˆ€ (x y : std_structure std_str) (f : x âŸ¶ y), f â‰« ğŸ™ y = f, from 
  begin intros x y f, apply hom_eq_C_std _ _, rwr comp_hom_std_C, hsimp end,
have as : âˆ€ (x y z w: std_structure std_str) (f : x âŸ¶ y) (g : y âŸ¶ z) (h : z âŸ¶ w),
          (f â‰« g) â‰« h = f â‰« (g â‰« h), from 
  begin intros x y z w f g h, apply hom_eq_C_std _ _, repeat { rwr comp_hom_std_C }, hsimp end,
precategory.mk ic ci as          

end

end categories

end hott