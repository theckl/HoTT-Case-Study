import sets.algebra init2 sets.axioms sets.theories categories.basic categories.adjoints

universes v v' u u' w 
hott_theory

namespace hott
open hott.eq hott.set hott.subset hott.is_trunc hott.is_equiv hott.equiv hott.categories
     hott.categories.adjoints 

namespace categories

/- Precategories whose type of objects is a set are called `strict categories` following 
   the [HoTT-Book,Ch.9.6], but they do not need to be categories. Thus we allow diagrams 
   with loops, that is cycles of homomorphisms that always yield the identity 
   homomorphism when composed. 
  
   Strict categories together with functors between them form a category. In particular, 
   equality of functors between strict categories is unique.  -/
@[hott]
structure strict_category :=
  (obj : Set.{u})
  (precat : precategory.{v} obj)

attribute [instance] strict_category.precat

@[hott, instance]
def functors_of_strict_cat_is_set (D‚ÇÅ D‚ÇÇ : strict_category) : 
  is_set (D‚ÇÅ.obj ‚•§ D‚ÇÇ.obj) :=
begin 
  fapply is_set.mk, intros F G p q, 
  rwr <- functor_eq_eta D‚ÇÅ.obj D‚ÇÇ.obj p, rwr <- functor_eq_eta D‚ÇÅ.obj D‚ÇÇ.obj q, 
  fapply apd011 (functor_eq D‚ÇÅ.obj D‚ÇÇ.obj), 
  { apply is_set.elim _ _, exact is_set_map },
  { apply pathover_of_tr_eq, 
    apply @set_po_eq (D‚ÇÅ.obj -> D‚ÇÇ.obj) 
                     (Œª f, Set.mk (Œ† (x y : D‚ÇÅ.obj), (x ‚ü∂ y) ‚Üí (f x ‚ü∂ f y)) _)
                     _ _ (ap functor.obj q) _ _ _ _, 
    change is_trunc 0 (Œ† (x : D‚ÇÅ.obj), Set.mk (Œ† (y : D‚ÇÅ.obj), (x ‚ü∂ y) ‚Üí (f x ‚ü∂ f y)) _), 
    apply is_set_dmap, 
    change is_trunc 0 (Œ† (y : D‚ÇÅ.obj), Set.mk ((x ‚ü∂ y) ‚Üí (f x ‚ü∂ f y)) _),
    apply is_set_dmap, exact is_set_map }
end    

@[hott, instance]
def strict_cat_has_hom : has_hom (strict_category) :=
  has_hom.mk (Œª D‚ÇÅ D‚ÇÇ : strict_category, Set.mk (D‚ÇÅ.obj ‚•§ D‚ÇÇ.obj) 
                                            (functors_of_strict_cat_is_set D‚ÇÅ D‚ÇÇ))     

@[hott, instance]
def strict_cat_cat_str : category_struct strict_category :=
  category_struct.mk (Œª D, id_functor D.obj) (Œª D‚ÇÅ D‚ÇÇ D‚ÇÉ F G, F ‚ãô G)

@[hott, instance]
def strict_cat_precat : precategory strict_category :=
precategory.mk (Œª D‚ÇÅ D‚ÇÇ F, funct_id_comp F) 
               (Œª D‚ÇÅ D‚ÇÇ F, funct_comp_id F) 
               (Œª D‚ÇÅ D‚ÇÇ D‚ÇÉ D‚ÇÑ F G H, funct_comp_assoc F G H)

namespace strict_cat

/- In the [HoTT-Book], three types of equivalences between (pre)categories are discussed :
   equivalences of (pre)categories [Def.9.4.1], isomorphisms of (pre)categories [Def.9.4.8]
   and equalities. They only are equivalent types if the precategories are categories 
   [Lem.9.4.15/16]. 
   
   However, from an isomorphism in the category of strict categories we can deduce an 
   isomorphism of precategories in the sense of [Def.9.4.8], and this allows us to 
   construct `isotoid` making `idtoiso` an equivalence in the precategory of strict 
   categories. 
   
   The construction of the equivalence is organised in 3 steps:
   The first step is to split up equalities of strict precategories in components and to 
   show that equalities of the components is equivalent to equality of the strict 
   precategories. -/ 
@[hott]
def flat_mk : Œ† (obj : Set.{u}) (hom : obj -> obj -> Set.{v}) 
  (id : Œ† a : obj, hom a a) (comp : Œ† {a b c}, hom a b -> hom b c -> hom a c),
  (Œ† {a b} (g : hom a b), comp (id a) g = g) ->
  (Œ† {a b} (f : hom a b), comp f (id b) = f) ->
  (Œ† {a b c d} (f : hom a b) (g : hom b c) (h : hom c d), 
       comp (comp f g) h = comp f (comp g h)) -> strict_category :=
assume obj hom id comp id_comp comp_id assoc, 
strict_category.mk obj (@precategory.mk ‚Ü•obj (@category_struct.mk ‚Ü•obj (has_hom.mk hom) 
                                                                  @id @comp) 
                                        @id_comp @comp_id @assoc)     

@[hott, hsimp]
def flat_eta (D : strict_category) : 
  D = flat_mk D.obj D.precat.to_has_hom.hom D.precat.to_category_struct.id 
              D.precat.to_category_struct.comp D.precat.id_comp D.precat.comp_id
              D.precat.assoc :=
begin 
  hinduction D with obj precat, hsimp, 
  hinduction precat with cat_str id_comp comp_id assoc, hsimp,
  hinduction cat_str with has_hom id comp, hinduction has_hom with hom, hsimp,
  exact idp
end              

@[hott]
def ap_obj_flat_eta (D : strict_category) : 
  ap strict_category.obj (flat_eta D) = @idp _ D.obj :=
begin 
  hinduction D with obj precat, hsimp, 
  hinduction precat with cat_str id_comp comp_id assoc, hsimp,
  hinduction cat_str with has_hom id comp, hinduction has_hom with hom, 
  change ap strict_category.obj idp = _, hsimp
end

@[hott]
structure flat_comp_eq (D‚ÇÅ D‚ÇÇ : strict_category) :=
  (p‚Çí : D‚ÇÅ.obj = D‚ÇÇ.obj)
  (p‚Çï : (Œª a b : D‚ÇÅ.obj, a ‚ü∂ b) =[p‚Çí; Œª D : Set, D -> D -> Set] (Œª a b : D‚ÇÇ.obj, a ‚ü∂ b))
  (p·µ¢ : (Œª a : D‚ÇÅ.obj, ùüô a) =[apd011 (Œª (D : Set) (h : D -> D -> Set), Œ† (a : D), h a a) 
                                     p‚Çí p‚Çï; id] (Œª a : D‚ÇÇ.obj, ùüô a))
  (pc : (Œª (a b c: D‚ÇÅ.obj) (f : a ‚ü∂ b) (g : b ‚ü∂ c), f ‚â´ g) =[apd011 
        (Œª (D : Set) (h : D -> D -> Set), Œ† (a b c : D), h a b -> h b c -> h a c) 
                        p‚Çí p‚Çï; id] (Œª (a b c: D‚ÇÇ.obj) (f : a ‚ü∂ b) (g : b ‚ü∂ c), f ‚â´ g))                                   

@[hott]
def flat_comp_eq_eta {D‚ÇÅ D‚ÇÇ : strict_category} (feq : flat_comp_eq D‚ÇÅ D‚ÇÇ) :
  feq = flat_comp_eq.mk feq.p‚Çí feq.p‚Çï feq.p·µ¢ feq.pc :=
begin hinduction feq, hsimp end 

@[hott]
def flat_comp_eq_eq {D‚ÇÅ D‚ÇÇ : strict_category} (feq‚ÇÅ feq‚ÇÇ : flat_comp_eq D‚ÇÅ D‚ÇÇ) :
  Œ† (q‚Çí : feq‚ÇÅ.p‚Çí = feq‚ÇÇ.p‚Çí), (feq‚ÇÅ.p‚Çï =[q‚Çí; Œª q : D‚ÇÅ.obj = D‚ÇÇ.obj, (Œª a b : D‚ÇÅ.obj, 
    (a ‚ü∂ b)) =[q; Œª D : Set, D -> D -> Set] Œª a b : D‚ÇÇ.obj, (a ‚ü∂ b)] feq‚ÇÇ.p‚Çï) -> 
    feq‚ÇÅ = feq‚ÇÇ :=
begin
  intros q‚Çí q‚Çï, rwr flat_comp_eq_eta feq‚ÇÅ, rwr flat_comp_eq_eta feq‚ÇÇ, 
  fapply apd01111_v2 flat_comp_eq.mk, 
  { exact q‚Çí },
  { exact q‚Çï },
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ },
  { apply pathover_of_tr_eq, exact is_prop.elim _ _ }
end   

@[hott]
def eq_to_flat_comp_eq  {D‚ÇÅ D‚ÇÇ : strict_category} : 
  D‚ÇÅ = D‚ÇÇ -> flat_comp_eq D‚ÇÅ D‚ÇÇ :=
begin 
  intro p, fapply flat_comp_eq.mk,  
  { exact ap strict_category.obj p },
  { sorry },
  { sorry },
  { sorry }, 
end  

@[hott]
structure comp_eq (D‚ÇÅ D‚ÇÇ : strict_category) :=
  (P‚Çí : D‚ÇÅ.obj = D‚ÇÇ.obj)  
  (P‚Çï : Œ† a b : D‚ÇÅ.obj, (a ‚ü∂ b) = (P‚Çí ‚ñ∏[Œª D : Set, D.carrier] a ‚ü∂ P‚Çí ‚ñ∏ b))
  (id_eq : Œ† a : D‚ÇÅ.obj, (P‚Çï a a) ‚ñ∏ ùüô a = ùüô (P‚Çí ‚ñ∏[Œª D : Set, D.carrier] a))
  (comp_hom_eq : Œ† (a b c : D‚ÇÅ.obj) (f : a ‚ü∂ b) (g : b ‚ü∂ c), (P‚Çï a c) ‚ñ∏ (f ‚â´ g) = 
                            ((P‚Çï a b) ‚ñ∏ f) ‚â´ ((P‚Çï b c) ‚ñ∏ g))                                               

@[hott]
def comp_eq_eta {D‚ÇÅ D‚ÇÇ : strict_category} (eq : comp_eq D‚ÇÅ D‚ÇÇ) :
  eq = comp_eq.mk eq.P‚Çí eq.P‚Çï eq.id_eq eq.comp_hom_eq :=
begin hinduction eq, hsimp end   

@[hott]
def eq_of_comp_eq {D‚ÇÅ D‚ÇÇ : strict_category} (ceq‚ÇÅ ceq‚ÇÇ : comp_eq D‚ÇÅ D‚ÇÇ) :
  Œ† (p‚Çí : ceq‚ÇÅ.P‚Çí = ceq‚ÇÇ.P‚Çí), (ceq‚ÇÅ.P‚Çï =[p‚Çí; Œª P : D‚ÇÅ.obj = D‚ÇÇ.obj, Œ† a b : D‚ÇÅ.obj, 
    (a ‚ü∂ b) = (P ‚ñ∏[Œª D : Set, D.carrier] a ‚ü∂ P ‚ñ∏ b)] ceq‚ÇÇ.P‚Çï) -> ceq‚ÇÅ = ceq‚ÇÇ :=
begin
  intros p‚Çí p‚Çï, rwr comp_eq_eta ceq‚ÇÅ, rwr comp_eq_eta ceq‚ÇÇ, 
  fapply apd01111_v2 comp_eq.mk, 
  { exact p‚Çí },
  { exact p‚Çï },
  { apply pathover_of_tr_eq, apply eq_of_homotopy, intro a, exact is_set.elim _ _ },
  { apply pathover_of_tr_eq, apply eq_of_homotopy3, intros a b c, 
                             apply eq_of_homotopy2, intros f g, exact is_set.elim _ _ }
end   

@[hott]
def idp_comp_eq (D : strict_category) : comp_eq D D :=
begin 
  fapply comp_eq.mk,
  { exact idp },
  { intros a b, hsimp },
  { intro a, hsimp },
  { intros a b c f g, hsimp } 
end

@[hott, hsimp]
def eq_to_obj_eq {D‚ÇÅ D‚ÇÇ : strict_category} : Œ† (p : D‚ÇÅ = D‚ÇÇ), D‚ÇÅ.obj = D‚ÇÇ.obj :=
  assume p, ap (Œª D : strict_category, D.obj) p

@[hott, hsimp]
def eq_to_obj_eq_idp (D : strict_category) : eq_to_obj_eq (@idp _ D) = @idp _ D.obj :=
  ap_idp _ _

@[hott, hsimp]
def eq_to_hom_eq {D‚ÇÅ D‚ÇÇ : strict_category} : 
  Œ† (p : D‚ÇÅ = D‚ÇÇ) (a b : D‚ÇÅ.obj), (a ‚ü∂ b) = (eq_to_obj_eq p ‚ñ∏[Œª D : Set, D.carrier] a ‚ü∂ 
                                              eq_to_obj_eq p ‚ñ∏ b) :=
begin 
  intro p, --apply fn2_eval_eq_to_deq, exact apd (Œª D : Set, @has_hom.hom D _) (eq_to_obj_eq p)
  hsimp, let H := apo100 p (apd (Œª D, @has_hom.hom ‚Ü•(D.obj) _) p), exact H 
end   

@[hott, hsimp]
def eq_to_hom_eq_idp {D : strict_category} (a b : D.obj) : 
  eq_to_hom_eq (@idp _ D) a b = @idp _ (a ‚ü∂ b) :=
begin hsimp, rwr cast_def end 

@[hott, hsimp]
def eq_to_comp_eq (D‚ÇÅ D‚ÇÇ : strict_category) : D‚ÇÅ = D‚ÇÇ -> comp_eq D‚ÇÅ D‚ÇÇ :=
begin
  intro p, fapply comp_eq.mk, 
  { exact eq_to_obj_eq p },
  { intros a b, exact eq_to_hom_eq p a b },
  { intro a, hinduction p, hsimp },
  { intros a b c f g, induction p, hsimp }
end    

@[hott]
def comp_eq_to_eq (D‚ÇÅ D‚ÇÇ : strict_category) : 
  comp_eq D‚ÇÅ D‚ÇÇ -> D‚ÇÅ = D‚ÇÇ :=
begin
  intro comp_eq, hinduction comp_eq with P‚Çí P‚Çï id_eq comp_eq,
  apply (Œª q, concat q (flat_eta D‚ÇÇ)‚Åª¬π), apply concat (flat_eta D‚ÇÅ),  
  fapply apd01d6 flat_mk,  
  { exact P‚Çí },
  { exact fn2_deq_to_eval_eq P‚Çí P‚Çï },
  { hinduction D‚ÇÅ with obj‚ÇÅ precat‚ÇÅ, hinduction D‚ÇÇ with obj‚ÇÇ precat‚ÇÇ,
    change obj‚ÇÅ = obj‚ÇÇ at P‚Çí, hinduction P‚Çí, hsimp,
    apply @fn2_po_adp011_idp_eq _ _ (Œª (A : Set) (b : A ‚Üí A ‚Üí Set), Œ† (a : A), b a a) 
                                    _ _ _ (eq_of_homotopy2 P‚Çï), 
    apply fn2_po_of_tr_eq (eq_of_homotopy2 P‚Çï), rwr ap100_eq_of_hty2_inv, exact id_eq },
  { hinduction D‚ÇÅ with obj‚ÇÅ precat‚ÇÅ, hinduction D‚ÇÇ with obj‚ÇÇ precat‚ÇÇ,
    change obj‚ÇÅ = obj‚ÇÇ at P‚Çí, hinduction P‚Çí, hsimp,
    apply @fn2_po_adp011_idp_eq _ _ (Œª (A : Set) (H : A ‚Üí A ‚Üí Set), 
             Œ† {a b c : A}, (H a b) ‚Üí (H b c) ‚Üí (H a c)) _ _ _ (eq_of_homotopy2 P‚Çï), 
    apply fn2_po_of_tr_eq' (eq_of_homotopy2 P‚Çï), rwr ap100_eq_of_hty2_inv, exact comp_eq },
  { apply pathover_of_tr_eq, apply eq_of_homotopy3, intros a b f, exact is_set.elim _ _ },
  { apply pathover_of_tr_eq, apply eq_of_homotopy3, intros a b f, exact is_set.elim _ _ },
  { apply pathover_of_tr_eq, apply eq_of_homotopy3, intros a b c, 
      apply eq_of_homotopy3, intros d f g, apply eq_of_homotopy, intro h, 
      exact is_set.elim _ _ }
end

@[hott]
def comp_eq_to_eq_obj {D‚ÇÅ D‚ÇÇ : strict_category} (ceq : comp_eq D‚ÇÅ D‚ÇÇ) :
  (eq_to_comp_eq D‚ÇÅ D‚ÇÇ (comp_eq_to_eq D‚ÇÅ D‚ÇÇ ceq)).P‚Çí = ceq.P‚Çí :=
begin 
  hinduction ceq, 
  change ap (Œª D : strict_category, D.obj) ((flat_eta D‚ÇÅ) ‚¨ù 
                              (apd01d6 flat_mk _ _ _ _ _ _ _) ‚¨ù (flat_eta D‚ÇÇ)‚Åª¬π) = P‚Çí,
  rwr ap_con, rwr ap_con, rwr ap_inv, 
  rwr ap_obj_flat_eta, rwr ap_obj_flat_eta, 
  rwr idp_inv, rwr idp_con, rwr con_idp, 
  let H' : Œ† o h i c ic ci as, strict_category.obj (flat_mk o h i c ic ci as) = o := 
    begin assume o h i c ic ci as, exact idp end,
  rwr ap_apd01d6 _ _ _ _ _ _ _ _ _ H', rwr idp_con
end  

@[hott]
def comp_eq_to_eq_hom {D‚ÇÅ D‚ÇÇ : strict_category} (ceq : comp_eq D‚ÇÅ D‚ÇÇ) :
  (eq_to_comp_eq D‚ÇÅ D‚ÇÇ (comp_eq_to_eq D‚ÇÅ D‚ÇÇ ceq)).P‚Çï =[comp_eq_to_eq_obj ceq; 
          Œª (P : D‚ÇÅ.obj = D‚ÇÇ.obj), Œ† (a b : D‚ÇÅ.obj), (a ‚ü∂ b) = (P ‚ñ∏ a ‚ü∂ P ‚ñ∏ b)] ceq.P‚Çï :=
begin
  apply pathover_of_tr_eq, apply eq_of_homotopy2, intros a b, 
  hinduction ceq, change _ = P‚Çï a b,
  hinduction D‚ÇÅ with obj‚ÇÅ precat‚ÇÅ, hinduction D‚ÇÇ with obj‚ÇÇ precat‚ÇÇ, 
  change obj‚ÇÅ = obj‚ÇÇ at P‚Çí, hinduction P‚Çí, change ‚Ü•obj‚ÇÅ at a, change ‚Ü•obj‚ÇÅ at b, 
  sorry
end  

@[hott]
def comp_eq_to_eq_idp (D : strict_category) : comp_eq_to_eq D D (idp_comp_eq D) = refl D :=
begin 
  change comp_eq_to_eq D D (comp_eq.mk _ _ _ _) = _, 
  hinduction D with obj precat, 
  change apd011 strict_category.mk _ _ = apd011 strict_category.mk idp idpo,
  fapply apd011 (apd011 strict_category.mk), 
  { refl }, 
  { apply pathover_of_tr_eq, change _ = pathover_idp_of_eq _ idp, 
    apply ap (pathover_idp_of_eq _), hinduction precat with cat_struct id_comp comp_id assoc,
    hsimp, change apd01111' (@precategory.mk _) _ _ _ _ = 
                                            apd01111' (@precategory.mk _) idp idpo idpo idpo,
    fapply apd01111' (apd01111' (@precategory.mk _)), 
    { hinduction cat_struct with has_hom id comp, hinduction has_hom with hom, hsimp, 
      change apd0111' (@category_struct.mk _) _ _ _ = 
                                               apd0111' (@category_struct.mk _) idp idpo idpo,
      fapply apd0111' (apd0111' (@category_struct.mk _)), 
      { change _ = ap has_hom.mk idp, apply ap (ap has_hom.mk), 
        change eq_of_homotopy2 (Œª (a b : ‚Ü•obj), idp) = _, rwr eq_of_homotopy2_id },
      { apply pathover_of_tr_eq, apply dep_set_eq_eq _ _ _, apply is_set_dmap' },
      { apply pathover_of_tr_eq, apply dep_set_eq_eq _ _ _, apply is_set_dmap' } },
    { apply pathover_of_tr_eq, apply dep_set_eq_eq _ _ _, apply is_set_dmap' },
    { apply pathover_of_tr_eq, apply dep_set_eq_eq _ _ _, apply is_set_dmap' },
    { apply pathover_of_tr_eq, apply dep_set_eq_eq _ _ _, apply is_set_dmap' } }
end  

@[hott]
def eq_eqv_comp_eq (D‚ÇÅ D‚ÇÇ : strict_category) : D‚ÇÅ = D‚ÇÇ ‚âÉ comp_eq D‚ÇÅ D‚ÇÇ :=
begin
  fapply equiv.mk, 
  { exact eq_to_comp_eq D‚ÇÅ D‚ÇÇ },
  { fapply adjointify, 
    { exact comp_eq_to_eq D‚ÇÅ D‚ÇÇ },
    { intro b, fapply eq_of_comp_eq, 
      { exact comp_eq_to_eq_obj b },
      { exact comp_eq_to_eq_hom b } },
    { intro p, hinduction p, exact comp_eq_to_eq_idp D‚ÇÅ } }
end                                 
  
/- Next, we adjointify the two natural transformations given by an isomorphism of two 
   precategories, as in [HoTT-Book,Lem.9.4.2]. This gives an equivalence of precategories. -/
@[hott]
def strict_cat_iso_to_obj_eqv : 
  Œ† {D‚ÇÅ D‚ÇÇ : strict_category}, (D‚ÇÅ ‚âÖ D‚ÇÇ) -> (D‚ÇÅ.obj ‚âÉ D‚ÇÇ.obj) :=
assume D‚ÇÅ D‚ÇÇ iD, equiv.mk iD.hom.obj (adjointify iD.hom.obj iD.inv.obj 
                                     (homotopy_of_eq (ap functor.obj iD.r_inv)) 
                                     (homotopy_of_eq (ap functor.obj iD.l_inv)))

@[hott]
def strict_cat_iso_to_obj_eq : 
  Œ† {D‚ÇÅ D‚ÇÇ : strict_category}, (D‚ÇÅ ‚âÖ D‚ÇÇ) -> (D‚ÇÅ.obj = D‚ÇÇ.obj) :=
assume D‚ÇÅ D‚ÇÇ iD, car_eq_to_set_eq (ua (strict_cat_iso_to_obj_eqv iD))                                                 

@[hott] 
def strict_cat_obj_tr_iso {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ) :
  Œ† d‚ÇÅ : D‚ÇÅ.obj, (strict_cat_iso_to_obj_eq iD) ‚ñ∏ d‚ÇÅ = iD.hom.obj d‚ÇÅ :=
begin
  intro d‚ÇÅ, 
  change (strict_cat_iso_to_obj_eq iD) ‚ñ∏[Œª A : Set, A.carrier] d‚ÇÅ = iD.hom.obj d‚ÇÅ, 
  rwr @tr_ap_id Set (Œª A : Set, A.carrier) _ _ (strict_cat_iso_to_obj_eq iD) d‚ÇÅ,
  change (set_eq_to_car_eq (car_eq_to_set_eq _)) ‚ñ∏[Œª D, D] d‚ÇÅ = _, 
  rwr rinv_set_eq_car_eq, change cast (ua (strict_cat_iso_to_obj_eqv iD)) d‚ÇÅ = _,
  rwr cast_ua
end  

@[hott]
def strict_cat_iso_to_unit_iso : 
  Œ† {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ), (iD.hom ‚ãô iD.inv) ‚âÖ id_functor D‚ÇÅ.obj :=
assume D‚ÇÅ D‚ÇÇ iD, idtoiso iD.l_inv

@[hott]
def strict_cat_iso_to_counit_iso_hom : 
  Œ† {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ), id_functor D‚ÇÇ.obj ‚üπ (iD.inv ‚ãô iD.hom) :=
begin
  intros D‚ÇÅ D‚ÇÇ iD, 
  let Œ∑ := strict_cat_iso_to_unit_iso iD, 
  let Œµ : id_functor ‚Ü•(D‚ÇÇ.obj) ‚âÖ iD‚Åª¬π ∞ ‚â´ iD.hom := inv_iso (idtoiso iD.r_inv),
  fapply nat_trans.mk, 
  { intro d‚ÇÇ, exact Œµ.hom.app d‚ÇÇ ‚â´ iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                    Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj (d‚ÇÇ))) },
  { intros d‚ÇÇ d‚ÇÇ' g,
    calc (id_functor ‚Ü•(D‚ÇÇ.obj)).map g ‚â´ Œµ.hom.app d‚ÇÇ' ‚â´ 
          iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ')) = 
               ((id_functor ‚Ü•(D‚ÇÇ.obj)).map g ‚â´ Œµ.hom.app d‚ÇÇ') ‚â´ 
                 iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ 
                 Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ')) : by rwr <- precategory.assoc
         ... = (Œµ.hom.app d‚ÇÇ ‚â´ iD.hom.map (iD‚Åª¬π ∞.map g)) ‚â´ 
                iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ 
                Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ')) : by rwr Œµ.hom.naturality
         ... = Œµ.hom.app d‚ÇÇ ‚â´ iD.hom.map (iD‚Åª¬π ∞.map g) ‚â´ 
               iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ 
               Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ')) : by rwr precategory.assoc;       
                                                          rwr precategory.assoc
         ... = Œµ.hom.app d‚ÇÇ ‚â´ iD.hom.map ((id_functor ‚Ü•(D‚ÇÅ.obj)).map (iD‚Åª¬π ∞.map g) ‚â´ 
               Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ _ : by hsimp
         ... = _ ‚â´ iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ) ‚â´ 
                   iD‚Åª¬π ∞.map (iD.hom.map (iD‚Åª¬π ∞.map g))) ‚â´ _ : by rwr Œ∑‚Åª¬π ∞.naturality
         ... = _ ‚â´ (iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                    iD.hom.map (iD‚Åª¬π ∞.map (iD.hom.map (iD‚Åª¬π ∞.map g)))) ‚â´ _ : by hsimp
         ... = _ ‚â´ _ ‚â´ iD.hom.map (iD‚Åª¬π ∞.map (iD.hom.map (iD‚Åª¬π ∞.map g))) ‚â´ 
                        Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ')) : by rwr precategory.assoc
         ... = _ ‚â´ _ ‚â´ (iD‚Åª¬π ∞ ‚â´ iD.hom).map (iD.hom.map (iD‚Åª¬π ∞.map g)) ‚â´ 
                        Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ')) : idp                
         ... = _ ‚â´ _ ‚â´ Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ iD.hom.map (iD‚Åª¬π ∞.map g) :                        
               by rwr Œµ‚Åª¬π ∞.naturality
         ... = (Œµ.hom.app d‚ÇÇ ‚â´ iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ))) ‚â´ (iD‚Åª¬π ∞ ‚ãô iD.hom).map g : 
                by rwr <- precategory.assoc; rwr <- precategory.assoc;
                   rwr precategory.assoc (Œµ.hom.app d‚ÇÇ)               }
end 

@[hott]
def strict_cat_iso_to_counit_iso_inv : 
  Œ† {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ), (iD.inv ‚ãô iD.hom) ‚üπ id_functor D‚ÇÇ.obj :=
begin
  intros D‚ÇÅ D‚ÇÇ iD, 
  let Œ∑ := strict_cat_iso_to_unit_iso iD, 
  let Œµ : id_functor ‚Ü•(D‚ÇÇ.obj) ‚âÖ iD‚Åª¬π ∞ ‚â´ iD.hom := inv_iso (idtoiso iD.r_inv),
  fapply nat_trans.mk, 
  { intro d‚ÇÇ, exact Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                    iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ },
  { intros d‚ÇÇ d‚ÇÇ' g,
    calc (iD‚Åª¬π ∞ ‚ãô iD.hom).map g ‚â´ Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj (d‚ÇÇ'))) ‚â´ 
                    iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ' = 
               ((iD‚Åª¬π ∞ ‚ãô iD.hom).map g ‚â´ Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj (d‚ÇÇ')))) ‚â´ 
                 iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ 
                 Œµ‚Åª¬π ∞.app d‚ÇÇ' : by rwr <- precategory.assoc
         ... = (Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                iD.hom.map (iD‚Åª¬π ∞.map (iD.hom.map (iD‚Åª¬π ∞.map g)))) ‚â´ 
                iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ' : by rwr Œµ.hom.naturality
         ... =  Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                (iD.hom.map (iD‚Åª¬π ∞.map (iD.hom.map (iD‚Åª¬π ∞.map g))) ‚â´ 
                iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ'))) ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ' : 
               by rwr precategory.assoc; rwr precategory.assoc
         ... = Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                iD.hom.map (iD‚Åª¬π ∞.map (iD.hom.map (iD‚Åª¬π ∞.map g)) ‚â´ 
                            Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ')) ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ' : by hsimp
         ... = _ ‚â´ iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ) ‚â´ 
                   (id_functor ‚Ü•(D‚ÇÅ.obj)).map (iD‚Åª¬π ∞.map g)) ‚â´ _ : by rwr Œ∑.hom.naturality
         ... = _ ‚â´ (iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                    iD.hom.map (iD‚Åª¬π ∞.map g)) ‚â´ _ : by hsimp
         ... = _ ‚â´ _ ‚â´ iD.hom.map (iD‚Åª¬π ∞.map g) ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ' : by rwr precategory.assoc
         ... = _ ‚â´ _ ‚â´ (iD‚Åª¬π ∞ ‚â´ iD.hom).map g ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ' : idp                
         ... = _ ‚â´ _ ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ ‚â´ (id_functor ‚Ü•(D‚ÇÇ.obj)).map g : by rwr Œµ‚Åª¬π ∞.naturality
         ... = (Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ) ‚â´ g : 
                by rwr <- precategory.assoc; rwr <- precategory.assoc;
                   rwr precategory.assoc (Œµ.hom.app _)               }
end 

@[hott]
def strict_cat_iso_to_counit_iso : 
  Œ† {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ), id_functor D‚ÇÇ.obj ‚âÖ (iD.inv ‚ãô iD.hom) :=
begin
  intros D‚ÇÅ D‚ÇÇ iD, 
  let Œ∑ := strict_cat_iso_to_unit_iso iD, let Œµ := inv_iso (idtoiso iD.r_inv),
  fapply iso.mk, 
  { exact strict_cat_iso_to_counit_iso_hom iD },
  { exact strict_cat_iso_to_counit_iso_inv iD },
  { apply nat_trans_eq, apply eq_of_homotopy, intro d‚ÇÇ,
    change (Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) 
           ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ) ‚â´ (Œµ.hom.app d‚ÇÇ ‚â´ iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
          Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj (d‚ÇÇ)))) = ùüô (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)), 
    rwr precategory.assoc, rwr <- precategory.assoc _ (Œµ.hom.app d‚ÇÇ) _, 
    rwr precategory.assoc _ _ (Œµ.hom.app d‚ÇÇ), 
    change _ ‚â´ (_ ‚â´ (Œµ‚Åª¬π ∞ ‚â´ Œµ.hom).app d‚ÇÇ) ‚â´ _ ‚â´ _ = _, rwr ap nat_trans.app Œµ.r_inv,
    change _ ‚â´ (_ ‚â´ ùüô ((iD‚Åª¬π ∞ ‚â´ iD.hom).obj d‚ÇÇ)) ‚â´ _ ‚â´ _ = _, rwr precategory.comp_id, 
    rwr <- precategory.assoc (iD.hom.map _), rwr <- functor.map_comp, 
    change _ ‚â´ iD.hom.map ((Œ∑.hom ‚â´ Œ∑‚Åª¬π ∞).app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ _ = _, 
    rwr ap nat_trans.app Œ∑.l_inv, change _ ‚â´ iD.hom.map (ùüô _) ‚â´ _ = _, rwr functor.map_id, 
    rwr precategory.id_comp, change (Œµ.hom ‚â´ Œµ‚Åª¬π ∞).app _ = _, rwr ap nat_trans.app Œµ.l_inv },
  { apply nat_trans_eq, apply eq_of_homotopy, intro d‚ÇÇ,
    change (Œµ.hom.app d‚ÇÇ ‚â´ iD.hom.map (Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
          Œµ‚Åª¬π ∞.app (iD.hom.obj (iD‚Åª¬π ∞.obj (d‚ÇÇ)))) ‚â´ (Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) 
           ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ) = ùüô d‚ÇÇ, 
    rwr precategory.assoc, rwr <- precategory.assoc _ (Œµ.hom.app _) _, 
    rwr precategory.assoc _ _ (Œµ.hom.app _), 
    change _ ‚â´ (_ ‚â´ (Œµ‚Åª¬π ∞ ‚â´ Œµ.hom).app _) ‚â´ _ ‚â´ _ = _, rwr ap nat_trans.app Œµ.r_inv,
    change _ ‚â´ (_ ‚â´ ùüô ((iD‚Åª¬π ∞ ‚â´ iD.hom).obj _)) ‚â´ _ ‚â´ _ = _, rwr precategory.comp_id,
    rwr <- precategory.assoc (iD.hom.map _), rwr <- functor.map_comp, 
    change _ ‚â´ iD.hom.map ((Œ∑‚Åª¬π ∞ ‚â´ Œ∑.hom).app _) ‚â´ _ = _, 
    rwr ap nat_trans.app Œ∑.r_inv, change _ ‚â´ iD.hom.map (ùüô _) ‚â´ _ = _, rwr functor.map_id, 
    rwr precategory.id_comp, change (Œµ.hom ‚â´ Œµ‚Åª¬π ∞).app _ = _, rwr ap nat_trans.app Œµ.l_inv }
end  

@[hott]
def strict_cat_iso_adj {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ) : 
  adjoint_functors iD.hom iD.inv :=
begin
  let Œ∑ := strict_cat_iso_to_unit_iso iD, let Œµ := inv_iso (idtoiso iD.r_inv),
  let Œµ' := strict_cat_iso_to_counit_iso iD,
  have H : Œ† d‚ÇÅ : D‚ÇÅ.obj, Œ∑.hom.app (iD‚Åª¬π ∞.obj (iD.hom.obj d‚ÇÅ)) = 
                                             iD‚Åª¬π ∞.map (iD.hom.map (Œ∑.hom.app d‚ÇÅ)), from
    begin 
      intro d‚ÇÅ, rwr <- precategory.comp_id (Œ∑.hom.app (iD‚Åª¬π ∞.obj (iD.hom.obj d‚ÇÅ))), 
      rwr <- precategory.comp_id (iD‚Åª¬π ∞.map (iD.hom.map (Œ∑.hom.app d‚ÇÅ))),  
      change Œ∑.hom.app (iD‚Åª¬π ∞.obj (iD.hom.obj d‚ÇÅ)) ‚â´ (ùüô (iD.hom ‚ãô iD‚Åª¬π ∞)).app d‚ÇÅ =
             iD‚Åª¬π ∞.map (iD.hom.map (Œ∑.hom.app d‚ÇÅ)) ‚â´ (ùüô (iD.hom ‚ãô iD‚Åª¬π ∞)).app d‚ÇÅ, 
      rwr <- apd10 (ap nat_trans.app Œ∑.l_inv) d‚ÇÅ, 
      change Œ∑.hom.app (iD‚Åª¬π ∞.obj (iD.hom.obj d‚ÇÅ)) ‚â´ Œ∑.hom.app d‚ÇÅ ‚â´ Œ∑‚Åª¬π ∞.app d‚ÇÅ =
             iD‚Åª¬π ∞.map (iD.hom.map (Œ∑.hom.app d‚ÇÅ)) ‚â´ Œ∑.hom.app d‚ÇÅ ‚â´ Œ∑‚Åª¬π ∞.app d‚ÇÅ,
      rwr <- precategory.assoc, rwr <- precategory.assoc, 
      rwr Œ∑.hom.naturality (Œ∑.hom.app d‚ÇÅ)
    end,
  have H' : Œ† d‚ÇÇ : D‚ÇÇ.obj, Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) = 
                                             iD.hom.map (iD‚Åª¬π ∞.map (Œµ.hom.app d‚ÇÇ)), from
    begin 
      intro d‚ÇÇ, rwr <- precategory.id_comp (Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ))), 
      rwr <- precategory.id_comp (iD.hom.map (iD‚Åª¬π ∞.map (Œµ.hom.app d‚ÇÇ))),        
      change (nat_trans_id (iD‚Åª¬π ∞ ‚ãô iD.hom)).app d‚ÇÇ ‚â´ _ = 
             (nat_trans_id (iD‚Åª¬π ∞ ‚ãô iD.hom)).app d‚ÇÇ ‚â´ _, 
      have p : nat_trans_id (iD‚Åª¬π ∞ ‚ãô iD.hom) = ùüô (iD‚Åª¬π ∞ ‚â´ iD.hom), from idp, rwr p,      
      rwr <- apd10 (ap nat_trans.app Œµ.r_inv) d‚ÇÇ, 
      change (Œµ‚Åª¬π ∞.app d‚ÇÇ ‚â´ Œµ.hom.app d‚ÇÇ) ‚â´ _ = (Œµ‚Åª¬π ∞.app d‚ÇÇ ‚â´ Œµ.hom.app d‚ÇÇ) ‚â´ _,
      rwr precategory.assoc, rwr precategory.assoc, 
      let p' : Œµ.hom.app d‚ÇÇ ‚â´ Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) =
                  Œµ.hom.app d‚ÇÇ ‚â´ iD.hom.map (iD‚Åª¬π ∞.map (Œµ.hom.app d‚ÇÇ)) := 
               Œµ.hom.naturality (Œµ.hom.app d‚ÇÇ), rwr p'
    end,  
  fapply adjoint_functors.mk, 
  { exact Œ∑.inv },
  { exact Œµ'.inv },
  { intro d‚ÇÅ, 
    change _ ‚â´ Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj (iD.hom.obj d‚ÇÅ))) ‚â´ 
      iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj (iD.hom.obj d‚ÇÅ))) ‚â´ Œµ‚Åª¬π ∞.app (iD.hom.obj d‚ÇÅ) = _,
    rwr H d‚ÇÅ, change _ ‚â´ _ ‚â´ (iD‚Åª¬π ∞ ‚â´ iD.hom).map (iD.hom.map (Œ∑.hom.app d‚ÇÅ)) ‚â´
                     Œµ‚Åª¬π ∞.app (iD.hom.obj ((id_functor ‚Ü•(D‚ÇÅ.obj)).obj d‚ÇÅ)) = _,
    rwr Œµ‚Åª¬π ∞.naturality (iD.hom.map (Œ∑.hom.app d‚ÇÅ)), 
    change _ ‚â´ _ ‚â´ _ ‚â´ iD.hom.map (Œ∑.hom.app d‚ÇÅ) = _,
    rwr <- precategory.assoc _ _ (iD.hom.map (Œ∑.hom.app d‚ÇÅ)), 
    change _ ‚â´ ((Œµ.hom ‚â´ Œµ‚Åª¬π ∞).app _) ‚â´ _ = _, rwr ap nat_trans.app Œµ.l_inv, 
    change _ ‚â´ ùüô (iD.hom.obj ((iD.hom ‚ãô iD‚Åª¬π ∞).obj d‚ÇÅ)) ‚â´ _ = _, 
    rwr precategory.id_comp, rwr <- functor.map_comp, 
    change iD.hom.map ((Œ∑‚Åª¬π ∞ ‚â´ Œ∑.hom).app d‚ÇÅ) = _, rwr ap nat_trans.app Œ∑.r_inv, hsimp },
  { intro d‚ÇÇ, 
    change _ ‚â´ iD‚Åª¬π ∞.map (Œµ.hom.app (iD.hom.obj (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ 
                           iD.hom.map (Œ∑.hom.app (iD‚Åª¬π ∞.obj d‚ÇÇ)) ‚â´ Œµ‚Åª¬π ∞.app d‚ÇÇ) = _, 
    rwr functor.map_comp, rwr functor.map_comp,       
    rwr H' d‚ÇÇ, rwr <- H (iD‚Åª¬π ∞.obj d‚ÇÇ),
    change _ ‚â´ (iD.hom ‚â´ iD‚Åª¬π ∞).map (iD‚Åª¬π ∞.map (Œµ.hom.app d‚ÇÇ)) ‚â´ _ ‚â´ _ = _,
    rwr <- precategory.assoc, 
    let p : _ = Œ∑‚Åª¬π ∞.app (iD‚Åª¬π ∞.obj d‚ÇÇ) ‚â´ (iD.hom ‚â´ iD‚Åª¬π ∞).map (iD‚Åª¬π ∞.map (Œµ.hom.app d‚ÇÇ)) 
          := Œ∑‚Åª¬π ∞.naturality (iD‚Åª¬π ∞.map (Œµ.hom.app d‚ÇÇ)), rwr <- p, 
    rwr precategory.assoc, rwr <- precategory.assoc _ _ (iD‚Åª¬π ∞.map (Œµ‚Åª¬π ∞.app d‚ÇÇ)), 
    change _ ‚â´ (Œ∑‚Åª¬π ∞ ‚â´ Œ∑.hom).app _ ‚â´ _ = _, rwr ap nat_trans.app Œ∑.r_inv,
    change _ ‚â´ ùüô (iD‚Åª¬π ∞.obj ((iD‚Åª¬π ∞ ‚â´ iD.hom).obj d‚ÇÇ)) ‚â´ _ = _, rwr precategory.id_comp,
    change iD‚Åª¬π ∞.map (Œµ.hom.app d‚ÇÇ) ‚â´ iD‚Åª¬π ∞.map (Œµ‚Åª¬π ∞.app d‚ÇÇ) = _, 
    rwr <- functor.map_comp, change iD‚Åª¬π ∞.map ((Œµ.hom ‚â´ Œµ‚Åª¬π ∞).app d‚ÇÇ) = _, 
    rwr ap nat_trans.app Œµ.l_inv, change iD‚Åª¬π ∞.map (ùüô d‚ÇÇ) = _, rwr functor.map_id }
end

/- Now we can use the triangle identities to construct a bijection between sets of 
   homomorphisms from isomorphisms of strict categories. -/
@[hott]
def strict_cat_iso_to_fully_faithful : Œ† {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ), 
  Œ† (a b : D‚ÇÅ.obj), bijection (a ‚ü∂ b) (functor.obj iD.hom a ‚ü∂ functor.obj iD.hom b) :=
begin
  intros D‚ÇÅ D‚ÇÇ iD a b, 
  let Œ∑ := strict_cat_iso_to_unit_iso iD, let Œµ := strict_cat_iso_to_counit_iso iD,
  fapply has_inverse_to_bijection, 
  { exact Œª f : a ‚ü∂ b, iD.hom.map f },
  { intro g, exact Œ∑‚Åª¬π ∞.app a ‚â´ iD.inv.map g ‚â´ Œ∑.hom.app b },
  { fapply is_set_inverse_of.mk,
    { intro g, hsimp, 
      have p : iD.hom.map (Œ∑.hom.app b) = Œµ‚Åª¬π ∞.app (iD.hom.obj b), from 
        calc _ = iD.hom.map (Œ∑.hom.app b) ‚â´ ùüô _ : by rwr <- precategory.comp_id
             ... = iD.hom.map (Œ∑.hom.app b) ‚â´ iD.hom.map (Œ∑‚Åª¬π ∞.app b) ‚â´ 
                                             Œµ‚Åª¬π ∞.app (iD.hom.obj b) : 
                   by rwr <- (strict_cat_iso_adj iD).zigzag_L
             ... = (iD.hom.map (Œ∑.hom.app b) ‚â´ iD.hom.map (Œ∑‚Åª¬π ∞.app b)) ‚â´ 
                                             Œµ‚Åª¬π ∞.app (iD.hom.obj b) : 
                   by rwr precategory.assoc 
             ... = iD.hom.map ((Œ∑.hom ‚â´ Œ∑‚Åª¬π ∞).app b) ‚â´ Œµ‚Åª¬π ∞.app (iD.hom.obj b) : by hsimp
             ... = iD.hom.map (ùüô ((iD.hom ‚ãô iD‚Åª¬π ∞).obj b)) ‚â´ Œµ‚Åª¬π ∞.app (iD.hom.obj b) : 
                   by rwr ap nat_trans.app Œ∑.l_inv 
             ... = ùüô (iD.hom.obj ((iD.hom ‚ãô iD‚Åª¬π ∞).obj b)) ‚â´ Œµ‚Åª¬π ∞.app (iD.hom.obj b) : 
                   by rwr functor.map_id                                                                   
             ... = _ : by rwr precategory.id_comp,
      rwr p, rwr Œµ‚Åª¬π ∞.naturality, 
      have p' : iD.hom.map (Œ∑‚Åª¬π ∞.app a) = Œµ.hom.app (iD.hom.obj a), from 
        calc _ = iD.hom.map (Œ∑‚Åª¬π ∞.app a) ‚â´ ùüô _ : by rwr precategory.comp_id
             ... = iD.hom.map (Œ∑‚Åª¬π ∞.app a) ‚â´ (Œµ‚Åª¬π ∞ ‚â´ Œµ.hom).app (iD.hom.obj a) : 
                   by rwr ap nat_trans.app Œµ.r_inv
             ... = iD.hom.map (Œ∑‚Åª¬π ∞.app a) ‚â´ Œµ‚Åª¬π ∞.app (iD.hom.obj a) ‚â´ 
                   Œµ.hom.app (iD.hom.obj a) : by refl
             ... = (iD.hom.map (Œ∑‚Åª¬π ∞.app a) ‚â´ Œµ‚Åª¬π ∞.app (iD.hom.obj a)) ‚â´ 
                   Œµ.hom.app (iD.hom.obj a) : by rwr precategory.assoc  
             ... = ùüô (iD.hom.obj a) ‚â´ Œµ.hom.app (iD.hom.obj a) : 
                   by rwr <- (strict_cat_iso_adj iD).zigzag_L                
             ... = _ : by rwr precategory.id_comp,
      rwr p', rwr <- precategory.assoc, change (Œµ.hom ‚â´ Œµ‚Åª¬π ∞).app (iD.hom.obj a) ‚â´ _ = _, 
      rwr ap nat_trans.app Œµ.l_inv, hsimp },
    { intro f, hsimp, rwr Œ∑.hom.naturality, rwr <- precategory.assoc, 
      change (Œ∑‚Åª¬π ∞ ‚â´ Œ∑.hom).app _ ‚â´ _ = _, rwr ap nat_trans.app Œ∑.r_inv, hsimp } },
end

@[hott, reducible]
def strict_cat_isotoid : Œ† {D‚ÇÅ D‚ÇÇ : strict_category}, (D‚ÇÅ ‚âÖ D‚ÇÇ) -> (D‚ÇÅ = D‚ÇÇ) :=
begin  
  intros D‚ÇÅ D‚ÇÇ iD, fapply strict_cat_eq, 
  { exact strict_cat_iso_to_obj_eq iD },
  { intros a b, 
    have p : (strict_cat_iso_to_obj_eq iD ‚ñ∏ a ‚ü∂ strict_cat_iso_to_obj_eq iD ‚ñ∏ b) =
             (iD.hom.obj a ‚ü∂ iD.hom.obj b), from 
      begin rwr strict_cat_obj_tr_iso iD a, rwr strict_cat_obj_tr_iso iD b end,
    apply (Œª q, eq.concat q p‚Åª¬π), 
    exact bij_to_set_eq (strict_cat_iso_to_fully_faithful iD a b) },
  { intro a, 
    change ((bij_to_set_eq (strict_cat_iso_to_fully_faithful iD a a)) ‚¨ù _) ‚ñ∏ ùüô a =_,
    rwr con_tr, rwr <- bij_hom_tr_eq, change _ ‚ñ∏ iD.hom.map (ùüô a) = _, 
    rwr functor.map_id, 
    have H_id : Œ† {d‚ÇÇ d‚ÇÇ' : D‚ÇÇ.obj} (p : d‚ÇÇ = d‚ÇÇ'), 
           (p‚Åª¬π ‚ñ∏[Œª d : D‚ÇÇ.obj, (d ‚ü∂ d‚ÇÇ) = (d‚ÇÇ' ‚ü∂ d‚ÇÇ')] 
           (p‚Åª¬π ‚ñ∏[Œª d : D‚ÇÇ.obj, (d‚ÇÇ' ‚ü∂ d) = (d‚ÇÇ' ‚ü∂ d‚ÇÇ')] idp))‚Åª¬π ‚ñ∏ (ùüô d‚ÇÇ') = ùüô d‚ÇÇ, from
      begin intros d‚ÇÇ d‚ÇÇ' p, hinduction p, hsimp end,  
    rwr H_id },
  { intros a b c f g, 
    change ((bij_to_set_eq (strict_cat_iso_to_fully_faithful iD a c)) ‚¨ù _) ‚ñ∏ f ‚â´ g =
           (((bij_to_set_eq (strict_cat_iso_to_fully_faithful iD a b)) ‚¨ù _) ‚ñ∏ f) ‚â´
           (((bij_to_set_eq (strict_cat_iso_to_fully_faithful iD b c)) ‚¨ù _) ‚ñ∏ g),
    rwr con_tr, rwr con_tr, rwr con_tr, rwr <- bij_hom_tr_eq, rwr <- bij_hom_tr_eq,
    rwr <- bij_hom_tr_eq, 
    change _ ‚ñ∏ iD.hom.map (f ‚â´ g) = (_ ‚ñ∏ iD.hom.map f) ‚â´ (_ ‚ñ∏ iD.hom.map g), 
    rwr functor.map_comp,
    have H_comp : Œ† {a b c a' b' c' : D‚ÇÇ.obj} (pa : a = a') (pb : b = b') (pc : c = c')
           (f : a' ‚ü∂ b') (g : b' ‚ü∂ c'), (pa‚Åª¬π ‚ñ∏[Œª d : D‚ÇÇ.obj, (d ‚ü∂ c) = (a' ‚ü∂ c')] 
           (pc‚Åª¬π ‚ñ∏[Œª d : D‚ÇÇ.obj, (a' ‚ü∂ d) = (a' ‚ü∂ c')] idp))‚Åª¬π ‚ñ∏ (f ‚â´ g) =
           ((pa‚Åª¬π ‚ñ∏[Œª d : D‚ÇÇ.obj, (d ‚ü∂ b) = (a' ‚ü∂ b')] 
           (pb‚Åª¬π ‚ñ∏[Œª d : D‚ÇÇ.obj, (a' ‚ü∂ d) = (a' ‚ü∂ b')] idp))‚Åª¬π ‚ñ∏ f) ‚â´
           ((pb‚Åª¬π ‚ñ∏[Œª d : D‚ÇÇ.obj, (d ‚ü∂ c) = (b' ‚ü∂ c')] 
           (pc‚Åª¬π ‚ñ∏[Œª d : D‚ÇÇ.obj, (b' ‚ü∂ d) = (b' ‚ü∂ c')] idp))‚Åª¬π ‚ñ∏ g), from 
      begin intros, hinduction pa, hinduction pb, hinduction pc, hsimp end,
    rwr H_comp }
end    

@[hott]
def strict_cat_isotoid_idfunct_obj_eq {D‚ÇÅ D‚ÇÇ : strict_category} (i : D‚ÇÅ ‚âÖ D‚ÇÇ) : 
  (strict_cat_isotoid i ‚ñ∏[Œª D : strict_category, D‚ÇÅ.obj ‚•§ D.obj] 
                                               id_functor ‚Ü•(D‚ÇÅ.obj)).obj = i.hom.obj :=
begin
  change (Œª D : strict_category, @functor.obj D‚ÇÅ.obj D.obj _ _) D‚ÇÇ 
                (strict_cat_isotoid i ‚ñ∏[Œª D : strict_category, D‚ÇÅ.obj ‚•§ D.obj] 
                id_functor (D‚ÇÅ.obj)) = _,
  rwr fn_tr_tr_ev (Œª D : strict_category, @functor.obj D‚ÇÅ.obj D.obj _ _), 
  apply tr_eq_of_pathover, apply pathover_of_pathover_ap (Œª D : Set, D‚ÇÅ.obj -> D), 
  apply pathover_of_tr_eq, rwr strict_cat_eq_obj_eta, apply eq_of_homotopy, intro d‚ÇÅ,
  rwr tr_fn_eval_tr', rwr strict_cat_obj_tr_iso
end                                                 

@[hott]
def strict_cat_isotoid_idfunct {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ) :=
  strict_cat_isotoid iD ‚ñ∏[Œª D : strict_category, D‚ÇÅ.obj ‚•§ D.obj] id_functor ‚Ü•(D‚ÇÅ.obj)

@[hott]
def strict_cat_isotoid_idfunct_map {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ) :=  
  Œª a b : D‚ÇÅ.obj, @functor.map _ _ _ _ (strict_cat_isotoid_idfunct iD) a b  

@[hott]
def strict_cat_isotoid_idfunct_map_eq {D‚ÇÅ D‚ÇÇ : strict_category} (iD : D‚ÇÅ ‚âÖ D‚ÇÇ) :
  strict_cat_isotoid_idfunct_map iD =[strict_cat_isotoid_idfunct_obj_eq iD;
                     Œª f : D‚ÇÅ.obj -> D‚ÇÇ.obj, Œ† (a b : D‚ÇÅ.obj), (a ‚ü∂ b) -> (f a ‚ü∂ f b)]
            iD.hom.map :=
begin
  apply pathover_of_tr_eq,   
  --rwr apdt, apply eq_of_homotopy3, intros a b f, 
  sorry
end  

end strict_cat

@[hott, instance]
def strict_cat_cat : category strict_category :=
begin
  apply category.mk, intros D‚ÇÅ D‚ÇÇ, fapply adjointify,
  { exact strict_cat_isotoid },
  { intro iD, change strict_cat_isotoid iD ‚ñ∏ (id_is_iso D‚ÇÅ) = iD, apply hom_eq_to_iso_eq,
    rwr fn2_tr_tr_ev (@iso.hom _ _), 
    change strict_cat_isotoid iD ‚ñ∏[Œª D : strict_category, D‚ÇÅ.obj ‚•§ D.obj] 
                                                                    id_functor D‚ÇÅ.obj = _,  
    fapply functor_eq, 
    { exact strict_cat_isotoid_idfunct_obj_eq iD },
    { exact strict_cat_isotoid_idfunct_map_eq iD } },
  { intro p, hinduction p, sorry }
end                 

end categories

end hott